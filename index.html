<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>道路生成器-高度调整</title>
    <!-- 引入Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="module.js"></script>
    <!-- Tailwind配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#6B7280',
                        accent: '#3B82F6',
                        surface: '#FFFFFF',
                        background: '#F5F7FA',
                        road: '#AAAAAA', // 调整为浅灰色
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                },
            }
        }
    </script>
    
    <!-- 自定义工具类 - 已替换@apply指令 -->
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .option-active {
                background-color: #165DFF;
                color: white;
                border-color: #165DFF;
            }
            .map-container {
                background-color: #62aff7ce; /* 黑色背景 */
                border: 1px solid #333;
                border-radius: 0.5rem;
                overflow: hidden;
                cursor: crosshair;
            }
        }
        /* 在CSS部分添加或修改 */
        #mouse-position-tooltip {
            position: fixed;
            background-color: rgba(30, 41, 59, 0.9);
            color: white;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            z-index: 1000;
            font-family: monospace;
            white-space: nowrap;
        }
    </style>
    
    <style>
        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }
        
        /* 自定义滚动条 */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        
        /* 道路生成动画 */
        @keyframes drawRoad {
            from {
                stroke-dashoffset: 1000;
            }
            to {
                stroke-dashoffset: 0;
            }
        }
        
        .road-path {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawRoad 0.5s forwards ease-out;
        }
        .object-type-button i {
            margin-right: 4px;
        }

        .object-type-button.option-active i {
            color: white;
        }
        /* 比例尺样式 */
        .scale-bar {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .scale-line {
            height: 2px;
            background-color: #333;
        }
        
        /* 选中道路样式 */
        .road-selected .road-path {
            filter: brightness(1.3);
            stroke: #165DFF;
            stroke-width: 1;
        }
        
        /* 选中路口样式 */
        .intersection-selected {
            filter: brightness(1.2);
            outline: 2px solid #165DFF;
            outline-offset: 2px;
        }
        
        .intersection-selected rect {
            stroke: #165DFF;
            stroke-width: 3;
        }
    </style>
</head>

<body class="bg-background min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- 页面标题 -->
        <header class="mb-8 text-center">
            <h1 class="text-[clamp(1.8rem,4vw,2.5rem)] font-bold text-gray-800 mb-2">
                <i class="fa fa-road mr-3 text-primary"></i>道路生成器
            </h1>
            <p class="text-gray-600 max-w-2xl mx-auto">
                通过简单的点击交互，生成道路和物体，创建自定义地图环境
            </p>
        </header>
        
        <!-- 主内容区域 -->
        <main class="flex flex-col lg:flex-row gap-6">
            <!-- 地图画布区域 -->
            <div class="flex-1">
                <div class="bg-white p-4 rounded-xl shadow-md mb-4">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-lg font-semibold text-gray-800">
                            <i class="fa fa-map mr-2 text-primary"></i>地图编辑区域
                        </h2>
                        <div class="text-sm text-gray-500" id="status-indicator">
                            <i class="fa fa-circle text-green-500 mr-1"></i>
                            就绪 - 请点击设定道路起点
                        </div>
                    </div>
                    
                    <!-- 地图容器 -->
                    <div class="map-container w-full aspect-[4/3] relative" id="map-container">
                        <!-- SVG 用于绘制道路 -->
                        <svg class="absolute inset-0 w-full h-full" id="map-svg"></svg>
                        
                        <!-- 道路起点和终点标记 -->
                        <div id="start-point" class="hidden absolute w-4 h-4 bg-green-500 rounded-full transform -translate-x-1/2 -translate-y-1/2"></div>
                        <div id="end-point" class="hidden absolute w-4 h-4 bg-red-500 rounded-full transform -translate-x-1/2 -translate-y-1/2"></div>
                        
                        <!-- 端点提示容器 -->
                        <div id="endpoint-hints" class="absolute inset-0 pointer-events-none"></div>
                        
                        <!-- 比例尺 -->
                        <div class="scale-bar" id="scale-bar">
                            <span id="scale-text">50px</span>
                            <div class="scale-line" id="scale-line" style="width: 50px;"></div>
                        </div>
                    </div>
                </div>
                
                <!-- 控制按钮 -->
                <div class="bg-white p-4 rounded-xl shadow-md flex flex-wrap gap-3">
                    <button id="clear-map" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg transition-all duration-300 flex items-center">
                        <i class="fa fa-trash mr-2"></i>清空地图
                    </button>
                    <!-- <button id="save-canvas" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-all duration-300 flex items-center">
                        <i class="fa fa-image mr-2"></i>保存地图数据
                    </button> -->

                    <button id="reset-scale" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg transition-all duration-300 flex items-center">
                        <i class="fa fa-gear mr-2"></i>重置比例尺
                    </button>

                    <button id="save-map-btn" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 transition-colors">
                        <i class="fa fa-save mr-1"></i> 保存地图项目
                    </button>
                    <button id="load-map-btn" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition-colors">
                        <i class="fa fa-load mr-1"></i> 加载项目
                    </button>
                    <input type="file" id="map-file-input" accept=".json" class="hidden">
                    <button id="save-canvas" class="px-4 py-2 bg-primary hover:bg-primary/90 text-white rounded-lg transition-all duration-300 flex items-center ml-auto">
                        <i class="fa fa-download mr-2"></i>导出地图结果
                    </button>
                </div>
            </div>
            
            <!-- 右侧选项器 -->
            <div class="w-full lg:w-80">
                <div class="bg-white p-4 rounded-xl shadow-md sticky top-4">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fa fa-sliders mr-2 text-primary"></i>选项器
                    </h2>
                    
                    <!-- 主模式选择（修改器/生成器） -->
                    <div class="mb-6">
                        <h3 class="text-sm font-medium text-gray-500 mb-2">主模式</h3>
                        <div class="flex space-x-2">
                            <button id="generator-mode" class="flex-1 px-3 py-2 border rounded-lg transition-all duration-300 option-active">
                                <i class="fa fa-plus-circle mr-1"></i>生成器
                            </button>
                            <button id="modifier-mode" class="flex-1 px-3 py-2 border border-gray-200 rounded-lg transition-all duration-300 hover:border-primary/50 hover:bg-primary/5">
                                <i class="fa fa-wrench mr-1"></i>编辑器
                            </button>
                        </div>
                    </div>
                    
                    <!-- 编辑模式选择 -->
                    <div class="mb-6" id="edit-mode-container">
                        <h3 class="text-sm font-medium text-gray-500 mb-2">编辑模式</h3>
                        <div class="grid grid-cols-2 gap-4">
                            <button id="road-mode-button" class="py-2 px-4 bg-primary text-white rounded-lg hover:bg-primary/90 transition-all duration-300 flex items-center justify-center option-active" onclick="switchMode('road')">
                                <i class="fa fa-road mr-2"></i>生成道路
                            </button>
                            <button id="object-mode-button" class="py-2 px-4 bg-white border border-gray-200 hover:border-primary/50 hover:bg-primary/5 text-gray-700 rounded-lg transition-all duration-300 flex items-center justify-center" onclick="switchMode('object')">
                                <i class="fa fa-cube mr-2"></i>生成物体
                            </button>
                            <button id="intersection-mode-button" class="py-2 px-4 bg-white border border-gray-200 hover:border-primary/50 hover:bg-primary/5 text-gray-700 rounded-lg transition-all duration-300 flex items-center justify-center" onclick="switchMode('intersection')">
                                <i class="fa fa-plus-square mr-2"></i>生成路口
                            </button>
                        </div>
                         
                        <!-- 路口类型选择器 -->
                        <div id="intersection-type-container" class="mt-4 hidden">
                            <h3 class="text-sm font-medium text-gray-500 mb-2">路口类型</h3>
                            <div class="grid grid-cols-3 gap-2">
                                <button id="cross-intersection-button" class="py-1 px-2 text-xs bg-primary text-white rounded border border-primary" onclick="selectIntersectionType('cross')">
                                    十字路口
                                </button>
                                <button id="t-junction-intersection-button" class="py-1 px-2 text-xs bg-white text-gray-700 rounded border border-gray-200 hover:border-primary/50 hover:bg-primary/5" onclick="selectIntersectionType('t-junction')">
                                    丁字路口
                                </button>
                                <button id="straight-intersection-button" class="py-1 px-2 text-xs bg-white text-gray-700 rounded border border-gray-200 hover:border-primary/50 hover:bg-primary/5" onclick="selectIntersectionType('straight')">
                                    直行路口
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 道路信息面板 -->
                    <div id="road-info-panel" class="space-y-4">
                        <h3 class="text-sm font-medium text-gray-500">道路信息</h3>
                        
                        <div class="grid grid-cols-2 gap-3 text-sm">
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div class="text-gray-500 mb-1">道路数量</div>
                                <div class="font-semibold text-gray-800" id="road-count">0</div>
                            </div>
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div class="text-gray-500 mb-1">总长度</div>
                                <div class="font-semibold text-gray-800" id="total-road-length">0 像素</div>
                            </div>
                        </div>
                    </div>

                    <!-- 主模式选择（修改器/生成器） -->
                    <div class="mb-6">
                        <!-- <div class="flex space-x-2"> -->
                            <button id="show-index" class="flex-1 px-3 py-2 border rounded-lg transition-all duration-300 option-active" onclick="toggleRoadID()">
                                <i class="fa fa-plus-circle mr-1"></i>显示道路ID
                            </button>
                            
                        <!-- </div> -->
                    </div>
                    
                    <!-- 物体信息面板（初始隐藏） -->
                    <div id="object-info-panel" class="space-y-4 hidden">
                        <h3 class="text-sm font-medium text-gray-500">物体信息</h3>
                        <div class="space-y-3">
                            <p class="text-sm text-gray-600">选择物体类型：</p>
                            <div class="grid grid-cols-2 gap-2" id="object-type-selector">
                                <button class="py-2 px-3 text-sm bg-primary text-white rounded-lg transition-all duration-300 object-type-button option-active" data-type="sign">
                                    <i class="fa fa-sign mr-1"></i>定位标牌
                                </button>
                                <button class="py-2 px-3 text-sm bg-white border border-gray-200 hover:border-primary/50 hover:bg-primary/5 text-gray-700 rounded-lg transition-all duration-300 object-type-button" data-type="gantry">
                                    <i class="fa fa-arrows-h mr-1"></i>龙门架
                                </button>
                                <button class="py-2 px-3 text-sm bg-white border border-gray-200 hover:border-primary/50 hover:bg-primary/5 text-gray-700 rounded-lg transition-all duration-300 object-type-button" data-type="bump">
                                    <i class="fa fa-road mr-1"></i>减速带
                                </button>
                                <button class="py-2 px-3 text-sm bg-white border border-gray-200 hover:border-primary/50 hover:bg-primary/5 text-gray-700 rounded-lg transition-all duration-300 object-type-button" data-type="tunnel">
                                    <i class="fa fa-subway mr-1"></i>隧道
                                </button>
                            </div>
                            <div class="mt-3 p-3 bg-blue-50 border border-blue-100 rounded-lg">
                                <p class="text-sm text-blue-700" id="object-instruction">
                                    <i class="fa fa-info-circle mr-1"></i>当前选择：定位标牌，请在地图上点击放置物体
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 参数编辑面板（初始隐藏） -->
                    <div id="parameter-panel" class="space-y-4 hidden">
                        <h3 class="text-sm font-medium text-gray-500">参数编辑</h3>
                        <p class="text-sm text-gray-400 mb-3" id="no-selection-text">请在修改器模式下点击道路进行选择</p>
                        
                        <div id="road-parameter-form" class="hidden space-y-4">
                            <div class="space-y-2">
                                <!-- 新增：选中道路的方向选择器 -->
                                <div class="flex justify-between items-center">
                                    <label class="text-sm text-gray-600">道路方向</label>
                                    <select id="selected-road-direction-select" class="text-sm border rounded px-2 py-1">
                                        <option value="one-way">单向</option>
                                        <option value="two-way">双向</option>
                                    </select>
                                </div>
                                
                                <!-- 新增：左侧车道数量输入框 -->
                                <!-- <div class="flex justify-between items-center left-lane-container">
                                    <label class="text-sm text-gray-600">左侧车道数量</label>
                                    <input type="number" min="0" max="10" value="0" class="text-sm border rounded px-2 py-1" id="selected-road-left-lanes-input">
                                </div> -->
                                
                                <!-- 新增：右侧车道数量输入框 -->
                                <!-- <div class="flex justify-between items-center">
                                    <label class="text-sm text-gray-600">右侧车道数量</label>
                                    <input type="number" min="1" max="10" value="1" class="text-sm border rounded px-2 py-1" id="selected-road-right-lanes-input">
                                </div> -->
                                
                                <!-- 新增：选中道路的曲率控制 -->
                                <div class="space-y-1">
                                    <div class="flex justify-between items-center">
                                        <label class="text-sm text-gray-600">道路曲率</label>
                                        <input type="number" min="-2" max="2" step="0.1" value="0" class="text-sm border rounded px-2 py-1" id="selected-road-curvature-input">
                                    </div>
                                    <input type="range" min="-1" max="1" step="0.1" value="0" class="w-full" id="selected-road-curvature-slider" oninput="document.getElementById('selected-road-curvature-input').value = this.value">
                                    <div class="flex justify-between text-xs text-gray-500">
                                        <span>向左弯曲</span>
                                        <span>直线</span>
                                        <span>向右弯曲</span>
                                    </div>
                                </div>
                                                                <!-- 新增：车道线设置区域 -->
                                <div class="space-y-3 mt-4">
                                    <h4 class="text-sm font-medium text-gray-500">车道线设置</h4>
                                    <div id="lane-markers-container" class="space-y-3">
                                        <!-- 车道线设置将通过JavaScript动态生成 -->
                                    </div>
                                </div>
                            </div>
                            <!-- <button id="apply-changes" class="w-full px-4 py-2 bg-primary hover:bg-primary/90 text-white rounded-lg transition-all duration-300 flex items-center justify-center">
                                <i class="fa fa-check mr-2"></i>应用修改
                            </button> -->
                        </div>
                    </div>
                </div>
            </div>
        </main>
        
        <!-- 页脚 -->
        <footer class="mt-12 text-center text-sm text-gray-500">
        </footer>
    </div>

    <!-- JavaScript -->
        <script>
        // 全局变量
        let currentMode = 'road'; // 当前模式：road 或 object 或 intersection
        let mainMode = 'generator'; // 主模式：generator 或 modifier
        let startPoint = null; // 道路起点
        let endPoint = null;
        let roads = []; // 存储所有道路数据
        let LandMarks = [];
        let connections = []; // 存储道路连接关系
        let intersections = []; // 存储所有路口数据
        let nextRoadId = 1; // 道路ID计数器
        let nextIntersectionId = 100; // 路口ID计数器
        // 添加路灯ID计数器
        let nextStreetLightId = 1;
        let selectedRoadLaneReductionSelect;
        let selectedRoadLeftLaneCountChangeSelect;
        let selectedRoadRightLaneCountChangeSelect;
        let roadIDgeneration = 0;
        // 在文件开头初始化nextZebraCrossingId变量
        let nextZebraCrossingId = 1;
        let selectedRoadId = null; // 当前选中的道路ID
        let selectedIntersectionId = null; // 当前选中的路口ID
        let isDrawingRoad = false; // 是否正在绘制道路
        let StartconnectedFrom = null; // 道路起点连接来源
        let EndconnectedTo = null; // 道路终点连接目标
        // let connectedFrom = null;
        // 道路参数
        let roadWidth = 10; // 道路宽度
        let roadDirection = 'two-way'; // 道路方向：two-way 或 one-way
        let roadLeftLanes = 1; // 左侧车道数
        let roadRightLanes = 1; // 右侧车道数
        let curvature = 0; // 道路曲率
        let scaleValue = 50; // 比例尺，默认50米
        let zoomFactor = 1; // 缩放因子
        let translateX = 0; // 平移X坐标
        let translateY = 0; // 平移Y坐标
        let isDragging = false; // 是否正在拖拽
        let lastMouseX = 0; // 上一次鼠标X坐标
        let lastMouseY = 0; // 上一次鼠标Y坐标
        let selectedIntersectionType = 'cross'; // 选中的路口类型：cross, t-junction, straight
        let nextLaneMarkerId = 1; // 车道线ID计数器
        let nextTrafficLightId = 1;
        let controlPoint = null; // 控制点，用于二阶曲线
        let controlPoints = null;
        let endpointHints = []; // 存储端点提示元素
        let inzone = false; //判断鼠标是否在顶点附近的标识
        let closestroad = 0;
        let closestroadtype = "none"
        let closestHint = null;
        let layoutchange = false;
        let nextStopLineId = 1;
        // 新增变量来跟踪拖拽状态
        let isDraggingIntersection = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let draggedIntersectionId = null;
        // 在全局变量部分添加
        let selectedObjectType = 'sign'; // 默认选择定位标牌
        let objects = []; // 存储所有生成的物体
        let nextObjectId = 1; // 物体ID计数器
        let objectName = '定位标牌';
        // DOM 元素
        const mapContainer = document.getElementById('map-container');
        const mapSvg = document.getElementById('map-svg');

        const intersectSvg = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        intersectSvg.classList.add('intersect-contents');
        

        const roadnumberSvg = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        roadnumberSvg.classList.add('road-number-contents');

        const roadSvg = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        roadSvg.classList.add('road-contents');



        mapSvg.appendChild(intersectSvg);
        mapSvg.appendChild(roadSvg);
        mapSvg.appendChild(roadnumberSvg);
        
        const startPointElement = document.getElementById('start-point');
        const endPointElement = document.getElementById('end-point');
        const statusIndicator = document.getElementById('status-indicator');
        const roadModeButton = document.getElementById('road-mode-button');
        const toggleidButton = document.getElementById('show-index');
        const objectModeButton = document.getElementById('object-mode-button');
        const roadInfoPanel = document.getElementById('road-info-panel');
        const objectInfoPanel = document.getElementById('object-info-panel');
        const roadCountElement = document.getElementById('road-count');
        const totalRoadLengthElement = document.getElementById('total-road-length');
        const saveCanvasButton = document.getElementById('save-canvas');
        const resetscalebutton = document.getElementById('reset-scale');
        // const saveprojectbutton = document.getElementById('save-map-btn');
        // const loadprojectbutton = document.getElementById('load-map-btn');
        // const mapfilechanged = document.getElementById('map-file-input');
        const roadWidthInput = document.getElementById('road-width-input');
        const clearMapButton = document.getElementById('clear-map');
        // const exportDataButton = document.getElementById('export-data');
        const generatorModeButton = document.getElementById('generator-mode');
        const modifierModeButton = document.getElementById('modifier-mode');
        const editModeContainer = document.getElementById('edit-mode-container');
        const parameterPanel = document.getElementById('parameter-panel');
        const roadParameterForm = document.getElementById('road-parameter-form');
        const noSelectionText = document.getElementById('no-selection-text');
        let selectedRoadWidthInput = document.getElementById('selected-road-width-input');
        let selectedRoadDirectionSelect = document.getElementById('selected-road-direction-select');
        let leftLaneContainer;
        let idshow = true;
        const scaleBar = document.getElementById('scale-bar');
        const scaleLine = document.getElementById('scale-line');
        const scaleText = document.getElementById('scale-text');
        const endpointHintsContainer = document.getElementById('endpoint-hints');
        // 新增：添加缺失的DOM元素引用
        let selectedRoadLeftLanesInput = document.getElementById('selected-road-left-lanes-input');
        let selectedRoadRightLanesInput = document.getElementById('selected-road-right-lanes-input');
                // 添加全局变量
        let validHints = []; // 存储所有满足距离条件的端点提示
        const intersectionTypeContainer = document.getElementById('intersection-type-container');
        const crossIntersectionButton = document.getElementById('cross-intersection-button');
        const tJunctionIntersectionButton = document.getElementById('t-junction-intersection-button');
        const straightIntersectionButton = document.getElementById('straight-intersection-button');
        const intersectionModeButton = document.getElementById('intersection-mode-button');

        // 初始化函数
        function init() {
            
            // 初始化SVG大小
            initSvgSize();
            updateRoadInfo();
            
                // 添加事件监听
            window.addEventListener('resize', initSvgSize);
            mapContainer.addEventListener('click', handleMapClick);
            mapContainer.addEventListener('mousemove', handleMouseMove);
            mapContainer.addEventListener('wheel', handleWheel);
            
            // 添加鼠标进入和离开画布的事件监听
            mapContainer.addEventListener('mouseenter', handleMouseEnter);
            mapContainer.addEventListener('mouseleave', handleMouseLeave);
            
            

            
            // 主模式切换事件监听
            generatorModeButton.addEventListener('click', () => switchMainMode('generator'));
            modifierModeButton.addEventListener('click', () => switchMainMode('modifier'));
            
            
            // 控制按钮事件监听
            document.getElementById('clear-map').addEventListener('click', clearMap);
            // document.getElementById('export-data').addEventListener('click', exportMapData);
            document.getElementById('save-canvas').addEventListener('click', exportMapResults);
            // document.getElementById('save-canvas').addEventListener('click', saveCanvas);
            document.getElementById('reset-scale').addEventListener('click', resetScale);
            // 添加保存和加载按钮的事件监听器
            // document.getElementById('save-map-btn').addEventListener('click', saveMapScene);
            document.getElementById('load-map-btn').addEventListener('click', loadMapScene);
            document.getElementById('map-file-input').addEventListener('change', handleMapFileSelect);
                        
            
            // 键盘事件监听
            document.addEventListener('keydown', handleKeyDown);

                // 添加物体类型选择按钮事件监听
            const objectTypeButtons = document.querySelectorAll('.object-type-button');
            objectTypeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // 移除所有按钮的选中状态
                    objectTypeButtons.forEach(btn => {
                        btn.classList.remove('option-active', 'bg-primary', 'text-white');
                        btn.classList.add('bg-white', 'border', 'border-gray-200', 'text-gray-700');
                    });
                    
                    // 设置当前按钮为选中状态
                    button.classList.add('option-active', 'bg-primary', 'text-white');
                    button.classList.remove('bg-white', 'border', 'border-gray-200', 'text-gray-700');
                    
                    // 更新选中的物体类型
                    selectedObjectType = button.getAttribute('data-type');
                    
                    // 更新提示信息
                    updateObjectInstruction(selectedObjectType);
                });
            });
            
        }

        function toggleRoadID(){
            idshow = !idshow;
            if(idshow){
                roadnumberSvg.classList.remove("hidden")
            }else{
                roadnumberSvg.classList.add("hidden")
            }
        }

        // 更新物体选择提示信息
        function updateObjectInstruction(objectType) {
            const instructionElem = document.getElementById('object-instruction');

            
            switch (objectType) {
                case 'sign':
                    objectName = '定位标牌';
                    break;
                case 'gantry':
                    objectName = '龙门架';
                    break;
                case 'bump':
                    objectName = '减速带';
                    break;
                case 'tunnel':
                    objectName = '隧道';
                    break;
            }
            
            instructionElem.innerHTML = `<i class="fa fa-info-circle mr-1"></i>当前选择：${objectName}，请在地图上点击放置物体`;
        }


        // 在exportMapData函数后添加保存场景函数
        function saveMapScene(customFileName) {
            // 准备完整的地图数据，包含roads、intersections和connections
            const mapSceneData = {
                metadata: {
                version: "1.0",
                exportTime: new Date().toISOString(),
                description: "道路环境场景数据"
                },
                DataType:"MapProject",
                roads:roads,
                // roads: roads.map(road => ({
                // id: road.id,
                // start: road.start,
                // end: road.end,
                // startalignref: road.startalignref,
                // endalignref: road.endalignref,
                // curvature: road.curvature,
                // width: road.width,
                // totalLanes: road.totalLanes,
                // direction: road.direction,
                // leftLanes: road.leftLanes,
                // rightLanes: road.rightLanes,
                // leftcurbelim: road.leftcurbelim,
                // rightcurbelim: road.rightcurbelim,
                // lanemarkers: road.lanemarkers,
                // roadedge: road.roadedge,
                // stopLines: road.stopLines,
                // arrows: road.arrows,
                // trafficlights: road.trafficlights,
                // connectionFrom: road.connectionFrom,
                // connectionTo: road.connectionTo
                // // 包含其他必要的属性
                // })),
                intersections: intersections,
                // .map(intersection => ({
                // id: intersection.id,
                // x: intersection.x,
                // y: intersection.y,
                // // 包含其他必要的属性
                // })),
                connections: connections,
                // .map(connection => ({
                // from_type: connection.from_type,
                // from_id: connection.from_id,
                // from_border: connection.from_border,
                // to_type: connection.to_type,
                // to_id: connection.to_id,
                // to_border: connection.to_border,
                // points: connection.points
                // // 包含其他必要的属性
                // }))
            };
            // 创建JSON文件
            const dataStr = JSON.stringify(mapSceneData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            // 创建下载链接
            const link = document.createElement('a');
            link.href = url;
            link.download = `${customFileName}.json`||'MapProject.json';
            
            // 触发下载
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // 释放URL对象
            URL.revokeObjectURL(url);
            
            // 显示提示
            showNotification('道路场景已保存', 'success');
        }
        // 添加加载场景函数
        function loadMapScene() {
            // 触发文件选择对话框
            document.getElementById('map-file-input').click();
        }
        // 修复drawZebraCrossing函数，实现完全自适应道路宽度的斑马线
        function drawZebraCrossing(road, roadGroup, centerLinePointsUnshift, direction, yellowLineMarker, gap,shifting) {
            // 斑马线参数设置
            const zebraLength = 4; // 斑马线长度为3米（沿道路方向）
            const zebraStripWidth = 0.5; // 每个白色条的宽度（垂直于道路方向）
            const zebraSpacing = 0.5; // 条之间的间隔
            const centerLinePoints = calculateOffsetPoints(centerLinePointsUnshift, 0);
            // 获取道路总宽度
            const roadWidth = road.width-2;
            
            // 根据行驶方向确定斑马线的位置
            let startPoint, directionVector;
            if (direction === 'right') {
                // 右侧行驶方向，起点靠近道路终点
                const endPointIndex = centerLinePoints.length - 1;
                const prevPointIndex = Math.max(0, endPointIndex - 1);
                
                startPoint = centerLinePoints[endPointIndex];
                // 计算方向向量（指向道路终点）
                directionVector = {
                    x: centerLinePoints[endPointIndex].x - centerLinePoints[prevPointIndex].x,
                    y: centerLinePoints[endPointIndex].y - centerLinePoints[prevPointIndex].y
                };
            } else {
                // 左侧行驶方向，起点靠近道路起点
                startPoint = centerLinePoints[0];
                const nextPointIndex = Math.min(centerLinePoints.length - 1, 1);
                // 计算方向向量（指向道路起点）
                directionVector = {
                    x: centerLinePoints[0].x - centerLinePoints[nextPointIndex].x,
                    y: centerLinePoints[0].y - centerLinePoints[nextPointIndex].y
                };
            }
            
            // 归一化方向向量
            const vectorLength = Math.max(0.001, Math.sqrt(directionVector.x * directionVector.x + directionVector.y * directionVector.y));
            directionVector.x /= vectorLength;
            directionVector.y /= vectorLength;
            
            // 计算垂直于道路方向的单位向量（用于确定斑马线宽度方向）
            const perpVector = {
                x: -directionVector.y,
                y: directionVector.x
            };
            
            // 初始化道路的斑马线数据数组（如果不存在）
            if (!road.zebraCrossings) {
                road.zebraCrossings = [];
            }
            
            // 创建一个数组来存储所有斑马线条带的点
            const zebraCrossingPoints = [];
            
            // 计算斑马线起始位置（停止线后1米）
            const stopLineOffset = 1; // 距离停止线的距离
            const zebraStartPoint = {
                x: startPoint.x + directionVector.x * stopLineOffset,
                y: startPoint.y + directionVector.y * stopLineOffset
            };
            
            // 动态计算条带数量：根据道路宽度和条带尺寸计算
            // 条带和间隔的组合单元宽度
            const unitWidth = zebraStripWidth + zebraSpacing;
            // 计算能够容纳在道路宽度内的完整单元数量
            const numStrips = Math.max(1, Math.floor(roadWidth / unitWidth));
            
            // 计算总宽度并确保它在道路宽度范围内
            const totalWidth = Math.min(numStrips * zebraStripWidth + (numStrips - 1) * zebraSpacing, roadWidth);
            const startOffset = -totalWidth / 2; // 从中间开始向两边排列
            
            // 绘制多个白色条带组成的斑马线（垂直于道路方向）
            for (let i = 0; i < numStrips; i++) {
                // 计算当前条带在垂直于道路方向上的位置偏移
                const positionOffset = startOffset + i * unitWidth;
                
                // 计算条带在道路方向上的起始和结束位置
                const stripFront = {
                    x: zebraStartPoint.x - directionVector.x * zebraLength,
                    y: zebraStartPoint.y - directionVector.y * zebraLength
                };
                
                const stripBack = zebraStartPoint;
                
                // 计算条带的左侧和右侧边界
                const leftFront = {
                    x: stripFront.x + perpVector.x * positionOffset,
                    y: stripFront.y + perpVector.y * positionOffset
                };
                
                const rightFront = {
                    x: stripFront.x + perpVector.x * (positionOffset + zebraStripWidth),
                    y: stripFront.y + perpVector.y * (positionOffset + zebraStripWidth)
                };
                
                const leftBack = {
                    x: stripBack.x + perpVector.x * positionOffset,
                    y: stripBack.y + perpVector.y * positionOffset
                };
                
                const rightBack = {
                    x: stripBack.x + perpVector.x * (positionOffset + zebraStripWidth),
                    y: stripBack.y + perpVector.y * (positionOffset + zebraStripWidth)
                };
                
                // 记录条带的四个角点
                zebraCrossingPoints.push([leftFront, rightFront, rightBack, leftBack]);
                
                // 创建白色矩形表示斑马线条带
                const stripPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                stripPath.setAttribute('d', `M ${leftFront.x},${leftFront.y} L ${rightFront.x},${rightFront.y} L ${rightBack.x},${rightBack.y} L ${leftBack.x},${leftBack.y} Z`);
                stripPath.setAttribute('fill', '#FFFFFF');
                stripPath.setAttribute('stroke', 'none');
                stripPath.classList.add('road-path', 'zebra-crossing');
                roadGroup.appendChild(stripPath);
            }
            
            // 记录斑马线数据到道路属性中
            road.zebraCrossings.push({
                id: nextZebraCrossingId++,
                direction: direction,
                yellowLineMarkerId: yellowLineMarker.id,
                length: zebraLength,
                strips: numStrips,
                stripWidth: zebraStripWidth,
                spacing: zebraSpacing,
                points: zebraCrossingPoints
            });
        }
        // 新增：计算三阶贝塞尔曲线上的点
        function calculateCubicBezierPoints(start, control1, control2, end, samplingInterval) {
            const points = [];
            const segments = 100;
            let totalLength = 0;
            const segmentPoints = [];
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const x = Math.pow(1 - t, 3) * start.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 
                          3 * (1 - t) * Math.pow(t, 2) * control2.x + Math.pow(t, 3) * end.x;
                const y = Math.pow(1 - t, 3) * start.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 
                          3 * (1 - t) * Math.pow(t, 2) * control2.y + Math.pow(t, 3) * end.y;
                segmentPoints.push({ x, y });
                
                if (i > 0) {
                    const prevPoint = segmentPoints[i - 1];
                    const dx = x - prevPoint.x;
                    const dy = y - prevPoint.y;
                    totalLength += Math.sqrt(dx * dx + dy * dy);
                }
            }
            
            // 根据采样间隔确定实际需要的采样点数
            const sampleCount = Math.max(2, Math.floor(totalLength / samplingInterval) + 1);
            
            // 按弧长均匀采样
            let accumulatedLength = 0;
            let targetLength = 0;
            let j = 1;
            
            points.push(start);
            
            for (let i = 1; i < sampleCount - 1; i++) {
                targetLength = (totalLength * i) / (sampleCount - 1);
                
                while (j < segmentPoints.length && accumulatedLength < targetLength) {
                    const prevPoint = segmentPoints[j - 1];
                    const currPoint = segmentPoints[j];
                    const dx = currPoint.x - prevPoint.x;
                    const dy = currPoint.y - prevPoint.y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);
                    
                    if (accumulatedLength + segmentLength >= targetLength) {
                        const ratio = (targetLength - accumulatedLength) / segmentLength;
                        const x = prevPoint.x + dx * ratio;
                        const y = prevPoint.y + dy * ratio;
                        points.push({ x, y });
                        break;
                    }
                    
                    accumulatedLength += segmentLength;
                    j++;
                }
            }
            
            points.push(end);
            
            return points;
        }
        
        // 修改：计算控制点位置 - 返回两个控制点
        function calculateControlPoint(start, end, curvature) {
            // 计算起点到终点的方向向量
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            
            // 计算中点
            const midX = (start.x + end.x) / 2;
            const midY = (start.y + end.y) / 2;
            
            // 计算垂直于方向向量的单位向量
            const length = Math.sqrt(dx * dx + dy * dy);
            const perpX = -dy / length;
            const perpY = dx / length;
            
            // 根据曲率计算控制点偏移距离
            const offset = (length / 4) * curvature;
            
            // 计算两个控制点位置（分布在曲线的1/3和2/3处）
            const control1X = (start.x + midX) / 2 + perpX * offset;
            const control1Y = (start.y + midY) / 2 + perpY * offset;
            const control2X = (midX + end.x) / 2 + perpX * offset;
            const control2Y = (midY + end.y) / 2 + perpY * offset;
            
            return { control1: { x: control1X, y: control1Y }, control2: { x: control2X, y: control2Y } };
        }

        // 检查点是否连接到路口
        function checkIfPointConnectedToIntersection(point) {
            // 检查连接关系中是否有点连接到路口
            return connections.some(conn => 
                (Math.abs(conn.points[0].x - point.x) < 5 && Math.abs(conn.points[0].y - point.y) < 5) ||
                (Math.abs(conn.points[1].x - point.x) < 5 && Math.abs(conn.points[1].y - point.y) < 5)
            );
        }

        // 为特定行驶方向绘制停止线
        function drawStopLinesForDirection(road, roadGroup, centerLinePoints, direction, yellowLineIndex,gap,shifting) {
            // 根据行驶方向确定需要连接的车道线
            let relevantMarkers = [];

            if (direction === 'right') {
                // 右侧行驶方向，取黄色分割线右侧的车道线（如果是双向道路）
                if (yellowLineIndex >= 0) {
                    relevantMarkers = road.lanemarkers.filter(marker => marker.index >= yellowLineIndex);
                } else {
                    // 单向道路，取所有车道线
                    relevantMarkers = road.lanemarkers;
                }
            } else if (direction === 'left') {
                // 左侧行驶方向，取黄色分割线左侧的车道线
                if (yellowLineIndex >= 0) {
                    relevantMarkers = road.lanemarkers.filter(marker => marker.index <= yellowLineIndex);
                }
            }

            // 按offset值对车道线进行排序
            relevantMarkers.sort((a, b) => {
                if (direction === 'right') return a.offset - b.offset;
                return b.offset - a.offset;
            });
            
            // 绘制停止线：连接相邻车道线的终点
            for (let i = 0; i < relevantMarkers.length - 1; i++) {
                const marker1 = relevantMarkers[i];
                const marker2 = relevantMarkers[i + 1];

                // 计算两个车道线终点的偏移点
                const offsetPoints1 = calculateOffsetPoints(centerLinePoints, marker1.offset);
                const offsetPoints2 = calculateOffsetPoints(centerLinePoints, marker2.offset);
                // 根据行驶方向确定终点位置
                let endPoint1, endPoint2;
                if (direction === 'right') {
                    // 右侧行驶方向，终点是道路的end
                    endPoint1 = offsetPoints1[offsetPoints1.length - 1-gap];
                    endPoint2 = offsetPoints2[offsetPoints2.length - 1-gap];
                    
                } else {
                    // 左侧行驶方向，终点是道路的start
                    endPoint1 = offsetPoints1[gap];
                    endPoint2 = offsetPoints2[gap];
                }

                // 绘制停止线（白色单实线）
                const stopLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');

                stopLine.setAttribute('x1', endPoint1.x);
                stopLine.setAttribute('y1', endPoint1.y);
                stopLine.setAttribute('x2', endPoint2.x);
                stopLine.setAttribute('y2', endPoint2.y);
                stopLine.setAttribute('stroke', '#FFFFFF');
                stopLine.setAttribute('stroke-width', '0.7');
                stopLine.classList.add('road-path', 'stop-line');
                roadGroup.appendChild(stopLine);
                
                // 记录停止线数据到道路属性中
                road.stopLines.push({
                    id: nextStopLineId++, // 需要在全局定义nextStopLineId变量
                    direction: direction,
                    laneMarkerIds: [marker1.id, marker2.id],
                    points: [endPoint1, endPoint2]
                });
            }
            
            //在绘制完所有的停止线后，绘制红绿灯
            if(road.direction == "two-way"){
                if (direction == "right"){
                    tfloffset = road.width/2 -5- road.rightLanes*3.75/2;
                }else{
                    tfloffset = road.width/2 -5- road.leftLanes*3.75/2;
                }
            }else{
                tfloffset = 0;
            }
            // 计算红绿灯位置
            // 确定道路终点方向
            let endPoint, prevPoint;
            if (direction === 'right') {
                // 右侧行驶方向，终点是道路的end
                endPoint = centerLinePoints[centerLinePoints.length - 1 - gap];
                prevPoint = centerLinePoints[centerLinePoints.length - 2 - gap];
            } else {
                // 左侧行驶方向，终点是道路的start
                endPoint = centerLinePoints[gap];
                prevPoint = centerLinePoints[gap + 1];
            }

            // 计算道路方向向量
            const dx = endPoint.x - prevPoint.x;
            const dy = endPoint.y - prevPoint.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const normalizedDx = dx / length;
            const normalizedDy = dy / length;

            // 计算垂直于道路方向的单位向量（用于偏移）
            const perpendicularDx = -normalizedDy;
            const perpendicularDy = normalizedDx;

            // 计算红绿灯位置：从终点沿道路反方向延伸10m，然后按偏移量横向移动
            const trafficLightX = endPoint.x + normalizedDx * 15 + perpendicularDx * tfloffset;
            const trafficLightY = endPoint.y + normalizedDy * 15 + perpendicularDy * tfloffset;

            // 设置红绿灯尺寸
            const width = 1; // 长边（宽度）
            const thickness = 3; // 短边（厚度）

            // 创建SVG矩形来表示红绿灯
            const trafficLight = document.createElementNS('http://www.w3.org/2000/svg', 'rect');

            // 计算矩形的位置和旋转
            // 根据道路方向计算旋转角度（红绿灯朝向道路，即与道路方向相反）
            const angle = Math.atan2(-normalizedDy, -normalizedDx) * 180 / Math.PI;

            // 设置矩形属性
            // 中心点坐标
            const rectX = trafficLightX - width / 2;
            const rectY = trafficLightY - thickness / 2;

            trafficLight.setAttribute('x', rectX);
            trafficLight.setAttribute('y', rectY);
            trafficLight.setAttribute('width', width);
            trafficLight.setAttribute('height', thickness);
            trafficLight.setAttribute('fill', '#000000');
            trafficLight.setAttribute('transform', `rotate(${angle} ${trafficLightX} ${trafficLightY})`);
            trafficLight.classList.add('road-path', 'traffic-light');

            // 添加到道路组
            roadGroup.appendChild(trafficLight);


            road.trafficlights.push({
                id: nextTrafficLightId || (nextTrafficLightId = 1),
                direction: direction,
                position: { x: trafficLightX, y: trafficLightY },
                rotation: angle,
                width: width,
                thickness: thickness
            });
            nextTrafficLightId = (nextTrafficLightId || 1) + 1;


            // 在绘制完所有停止线后，绘制斑马线（如果是双向道路）
            if (road.direction === 'two-way' && yellowLineIndex >= 0) {
                // 找到中央黄线对应的marker
                const yellowLineMarker = road.lanemarkers.find(marker => marker.index === yellowLineIndex);
                if (yellowLineMarker) {
                    drawZebraCrossing(road, roadGroup, centerLinePoints, direction, yellowLineMarker, gap,shifting);
                }
            }else{
                drawZebraCrossing(road, roadGroup, centerLinePoints, direction, [], gap,0);
            }
        }
        
        // 绘制路灯函数
        function drawStreetLights(road, roadGroup) {
            // 确保road.streetLights数组存在
            if (!road.streetLights) {
                road.streetLights = [];
            } else {
                // 清空现有路灯数据
                road.streetLights = [];
                // 移除已有的路灯SVG元素
                const existingLights = roadGroup.querySelectorAll('.street-light');
                existingLights.forEach(light => light.remove());
            }
            
            let samplingPoints;

            // 遍历道路的两个边缘（左边缘和右边缘）
            road.roadedge.forEach((edge, edgeIndex) => {
                if (edge.type == 'left_curb'){ ;
                    samplingPoints = calculateOffsetPoints(edge.samplingPoints, 3.5);
                }else if (edge.type == 'right_curb'){
                    samplingPoints = calculateOffsetPoints(edge.samplingPoints, -3.5);
                }

                if (!samplingPoints || samplingPoints.length < 2) return;

                // 计算道路边缘总长度
                let totalLength = 0;
                const pointDistances = [];
                pointDistances.push(0); // 第一个点距离为0

                for (let i = 1; i < samplingPoints.length; i++) {
                    const dx = samplingPoints[i].x - samplingPoints[i-1].x;
                    const dy = samplingPoints[i].y - samplingPoints[i-1].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    totalLength += distance;
                    pointDistances.push(totalLength);
                }

                // 从起点后5m开始，每10m放置一个路灯
                const startOffset = 20; // 起始偏移5米
                const interval = 60; // 间隔10米
                let currentPosition = startOffset;
                while (currentPosition < totalLength) {
                    // 找到当前位置对应的点和下一个点
                    let pointIndex = 0;
                    for (let i = 0; i < pointDistances.length - 1; i++) {
                        if (currentPosition >= pointDistances[i] && currentPosition <= pointDistances[i+1]) {
                            pointIndex = i;
                            break;
                        }
                    }

                    // 计算在两点之间的精确位置
                    const ratio = (currentPosition - pointDistances[pointIndex]) / 
                                (pointDistances[pointIndex+1] - pointDistances[pointIndex]);
                    const x = samplingPoints[pointIndex].x + 
                            (samplingPoints[pointIndex+1].x - samplingPoints[pointIndex].x) * ratio;
                    const y = samplingPoints[pointIndex].y + 
                            (samplingPoints[pointIndex+1].y - samplingPoints[pointIndex].y) * ratio;
                    const z = (samplingPoints[pointIndex].z + samplingPoints[pointIndex+1].z) /2;

                    // 计算道路边缘在该点的方向
                    let directionX, directionY;
                    if (pointIndex === samplingPoints.length - 1) {
                        // 最后一个点，使用前一个方向
                        directionX = samplingPoints[pointIndex].x - samplingPoints[pointIndex-1].x;
                        directionY = samplingPoints[pointIndex].y - samplingPoints[pointIndex-1].y;
                    } else {
                        directionX = samplingPoints[pointIndex+1].x - samplingPoints[pointIndex].x;
                        directionY = samplingPoints[pointIndex+1].y - samplingPoints[pointIndex].y;
                    }

                    // 计算垂直于道路边缘的向量（指向道路中心线）
                    // 根据是左边缘还是右边缘确定方向
                    const isLeftEdge = edgeIndex === 0;
                    let perpendicularX = isLeftEdge ? directionY : -directionY;

                    let perpendicularY = isLeftEdge ? -directionX : directionX;

                    // 归一化垂直向量
                    const perpLength = Math.sqrt(perpendicularX * perpendicularX + perpendicularY * perpendicularY);
                    if (perpLength > 0) {
                        perpendicularX /= perpLength;
                        perpendicularY /= perpLength;
                    }

                    // 计算路灯的朝向角度（与道路边缘垂直）
                    const angle = Math.atan2(perpendicularY, perpendicularX) * (180 / Math.PI);

                    // 创建路灯SVG元素（黑色矩形）
                    const light = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    light.setAttribute('x', x - 0.15); // 宽度为0.3
                    light.setAttribute('y', y - 0.35); // 高度为0.7
                    light.setAttribute('width', '3');
                    light.setAttribute('height', '0.3');
                    light.setAttribute('fill', '#FFF000');
                    light.setAttribute('transform', `rotate(${angle} ${x} ${y})`);
                    light.classList.add('road-path', 'street-light');
                    roadGroup.appendChild(light);

                    // 记录路灯数据
                    road.streetLights.push({
                        id: nextStreetLightId++,
                        position: { x, y, z },
                        rotation: angle,
                        edgeIndex: edgeIndex,
                        distanceFromStart: currentPosition
                    });

                    // 移动到下一个路灯位置
                    currentPosition += interval;
                }
            });
        }

        // 显示端点选择对话框
        function showHintSelectionDialog(hints) {
            return new Promise((resolve) => {
                // 创建对话框
                const dialog = document.createElement('div');
                dialog.className = 'hint-selection-dialog fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                
                const dialogContent = document.createElement('div');
                dialogContent.className = 'bg-white rounded-lg shadow-lg p-6 w-80 max-w-full';
                
                const dialogTitle = document.createElement('h3');
                dialogTitle.className = 'text-xl font-bold mb-4';
                dialogTitle.textContent = '选择连接端点';
                
                const hintList = document.createElement('div');
                hintList.className = 'space-y-2 mb-4 max-h-60 overflow-y-auto';
                
                // 创建单选按钮组
                hints.forEach((item, index) => {
                    const hint = item.hint;
                    const hintInfo = document.createElement('div');
                    hintInfo.className = 'flex items-center p-2 border rounded cursor-pointer hover:bg-gray-100';
                    
                    const radioInput = document.createElement('input');
                    radioInput.type = 'radio';
                    radioInput.name = 'selectedHint';
                    radioInput.value = index;
                    radioInput.id = `hint-${index}`;
                    radioInput.className = 'mr-2';
                    if (index === 0) radioInput.checked = true; // 默认选中第一个
                    
                    const radioLabel = document.createElement('label');
                    radioLabel.htmlFor = `hint-${index}`;
                    radioLabel.className = 'flex-1 cursor-pointer';
                    
                    const hintType = hint.dataset.type === 'road' ? '道路' : '路口';
                    radioLabel.textContent = `端点 ${index + 1}: ${hintType} ID: ${hint.dataset.road}`;
                    
                    hintInfo.appendChild(radioInput);
                    hintInfo.appendChild(radioLabel);
                    hintList.appendChild(hintInfo);
                });
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex justify-end space-x-2';
                
                const cancelButton = document.createElement('button');
                cancelButton.className = 'px-4 py-2 bg-gray-200 rounded hover:bg-gray-300';
                cancelButton.textContent = '取消';
                
                const confirmButton = document.createElement('button');
                confirmButton.className = 'px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600';
                confirmButton.textContent = '确定';
                
                buttonContainer.appendChild(cancelButton);
                buttonContainer.appendChild(confirmButton);
                
                dialogContent.appendChild(dialogTitle);
                dialogContent.appendChild(hintList);
                dialogContent.appendChild(buttonContainer);
                dialog.appendChild(dialogContent);
                document.body.appendChild(dialog);
                
                // 处理按钮点击事件
                cancelButton.addEventListener('click', () => {
                    document.body.removeChild(dialog);
                    resolve(null); // 用户取消选择
                });
                
                confirmButton.addEventListener('click', () => {
                    const selectedIndex = parseInt(document.querySelector('input[name="selectedHint"]:checked').value);
                    const selectedHint = hints[selectedIndex].hint;
                    document.body.removeChild(dialog);
                    resolve(selectedHint); // 返回用户选择的端点
                });
                
                // 点击对话框外部关闭
                dialog.addEventListener('click', (e) => {
                    if (e.target === dialog) {
                        document.body.removeChild(dialog);
                        resolve(null);
                    }
                });
                
                // 按ESC键关闭
                const handleEsc = (e) => {
                    if (e.key === 'Escape') {
                        document.body.removeChild(dialog);
                        resolve(null);
                        document.removeEventListener('keydown', handleEsc);
                    }
                };
                document.addEventListener('keydown', handleEsc);
            });
        }

        // 根据物体类型获取物体名称
        function getObjectTypeName(objectType) {
            switch (objectType) {
                case 'sign': return '定位标牌';
                case 'gantry': return '龙门架';
                case 'bump': return '减速带';
                case 'tunnel': return '隧道';
                default: return '物体';
            }
        }

        // 处理地图容器点击事件
        function handleMapClick(event) {
            // 阻止事件冒泡
            event.stopPropagation();

            // 检查是否正在拖拽
            if (isDragging) return;
            
            // 在修改器模式下，点击道路进行选择
            if (mainMode === 'modifier') {
                handleModifierClick(event)
                return;
            }
            if (mainMode == 'generator' && zoomFactor == 1){
                if (currentMode === 'object') {
                        // 获取点击位置（考虑缩放和平移）
                    const rect = mapContainer.getBoundingClientRect();
                    const currentroad = event.target.closest('.road-shape-group');
                    const x = (event.clientX - rect.left - translateX) / zoomFactor;
                    const y = (event.clientY - rect.top - translateY) / zoomFactor;
                    // 放置物体
                    placeObject(x, y, selectedObjectType, currentroad);
                }
                // 在生成器模式下，根据当前模式处理点击
                else if (currentMode !== 'object') {
                    const rect = mapContainer.getBoundingClientRect();
                    let posx, posy;
                    
                    if (inzone && validHints && validHints.length > 1) {
                        // 如果有多个满足条件的端点，显示选择弹窗
                        // 由于showHintSelectionDialog是异步的，我们需要重新组织代码流程
                        handleMultiHintClick(event, rect);
                        return; // 提前返回，等待用户选择后再继续处理
                    } else if (inzone) {
                        // 只有一个满足条件的端点，直接使用
                        posx = parseFloat(closestHint.dataset.x);
                        posy = parseFloat(closestHint.dataset.y);
                        processMapClick(posx, posy, closestHint);
                    } else {
                        // 没有满足条件的端点，使用鼠标点击位置
                        posx = parseInt(event.clientX - rect.left);
                        posy = parseInt(event.clientY - rect.top);
                        processMapClick(posx, posy, null);
                    }
                }
            }else if (mainMode == 'generator' && zoomFactor != 1){
                    showNotification('请通过重置比例尺按钮将地图缩放至原始大小', 'warning');
                }
        
        }

        // 放置物体函数
        function placeObject(x, y, objectType, currentroad) {
            // 创建物体数据
            const object = {
                id: nextObjectId++,
                type: objectType,
                x: x,
                y: y,
                rotation: 0 // 初始旋转角度
            };
            if(currentroad){
                parentrode = roads.find(road => road.id == currentroad.dataset.roadId);
                allpoints = parentrode.leftboundshape.concat(parentrode.rightboundshape);
                currentpos = {
                    x: x,
                    y: y
                }
                point_index = findNearestPoint(currentpos,allpoints)
                if (point_index > parentrode.leftboundshape.length){
                    console.log("It's on the rightside",parentrode)
                }else{
                    console.log("It's on the leftside")
                }
            }
            // 添加到物体数组
            objects.push(object);
            
            // 绘制物体（这里简化处理，实际应根据物体类型绘制不同的图形）
            drawObject(object);
            
            // 更新状态提示
            statusIndicator.innerHTML = `<i class="fa fa-circle text-green-500 mr-1"></i>已放置${getObjectTypeName(objectType)}，请继续放置或切换模式`;
        }

        // 绘制物体函数（简化版，实际应根据不同物体类型绘制不同图形）
        function drawObject(object) {
            // 创建一个组来包含物体的所有元素
            const objectGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            objectGroup.setAttribute('data-object-id', object.id);
            
            // 根据物体类型绘制不同的图形
            let shape;
            switch (object.type) {
                case 'sign':
                    // 绘制定位标牌（简化为矩形+文字）
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shape.setAttribute('x', object.x - 10);
                    shape.setAttribute('y', object.y - 20);
                    shape.setAttribute('width', 20);
                    shape.setAttribute('height', 40);
                    shape.setAttribute('fill', '#FF6B6B');
                    shape.setAttribute('stroke', '#333');
                    shape.setAttribute('stroke-width', '1');
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', object.x);
                    text.setAttribute('y', object.y);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('font-size', '8');
                    text.setAttribute('fill', 'white');
                    text.textContent = '标牌';
                    
                    objectGroup.appendChild(shape);
                    objectGroup.appendChild(text);
                    break;
                    
                case 'gantry':
                    // 绘制龙门架（简化为矩形）
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shape.setAttribute('x', object.x - 20);
                    shape.setAttribute('y', object.y - 15);
                    shape.setAttribute('width', 40);
                    shape.setAttribute('height', 30);
                    shape.setAttribute('fill', '#4ECDC4');
                    shape.setAttribute('stroke', '#333');
                    shape.setAttribute('stroke-width', '1');
                    
                    const gantryText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    gantryText.setAttribute('x', object.x);
                    gantryText.setAttribute('y', object.y);
                    gantryText.setAttribute('text-anchor', 'middle');
                    gantryText.setAttribute('dominant-baseline', 'middle');
                    gantryText.setAttribute('font-size', '8');
                    gantryText.setAttribute('fill', 'white');
                    gantryText.textContent = '龙门架';
                    
                    objectGroup.appendChild(shape);
                    objectGroup.appendChild(gantryText);
                    break;
                    
                case 'bump':
                    // 绘制减速带（简化为圆角矩形）
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shape.setAttribute('x', object.x - 15);
                    shape.setAttribute('y', object.y - 5);
                    shape.setAttribute('width', 30);
                    shape.setAttribute('height', 10);
                    shape.setAttribute('rx', 2);
                    shape.setAttribute('fill', '#FFD166');
                    shape.setAttribute('stroke', '#333');
                    shape.setAttribute('stroke-width', '1');
                    
                    const bumpText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    bumpText.setAttribute('x', object.x);
                    bumpText.setAttribute('y', object.y);
                    bumpText.setAttribute('text-anchor', 'middle');
                    bumpText.setAttribute('dominant-baseline', 'middle');
                    bumpText.setAttribute('font-size', '6');
                    bumpText.setAttribute('fill', '#333');
                    bumpText.textContent = '减速带';
                    
                    objectGroup.appendChild(shape);
                    objectGroup.appendChild(bumpText);
                    break;
                    
                case 'tunnel':
                    // 绘制隧道（简化为梯形）
                    const tunnelPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tunnelPath.setAttribute('d', 
                        `M ${object.x - 25},${object.y - 10} ` +
                        `L ${object.x - 20},${object.y - 25} ` +
                        `L ${object.x + 20},${object.y - 25} ` +
                        `L ${object.x + 25},${object.y - 10} ` +
                        `Z`
                    );
                    tunnelPath.setAttribute('fill', '#6B7280');
                    tunnelPath.setAttribute('stroke', '#333');
                    tunnelPath.setAttribute('stroke-width', '1');
                    
                    const tunnelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    tunnelText.setAttribute('x', object.x);
                    tunnelText.setAttribute('y', object.y - 15);
                    tunnelText.setAttribute('text-anchor', 'middle');
                    tunnelText.setAttribute('dominant-baseline', 'middle');
                    tunnelText.setAttribute('font-size', '8');
                    tunnelText.setAttribute('fill', 'white');
                    tunnelText.textContent = '隧道';
                    
                    objectGroup.appendChild(tunnelPath);
                    objectGroup.appendChild(tunnelText);
                    break;
            }
            
            // 将物体添加到SVG中
            mapSvg.appendChild(objectGroup);
        }
        
        // 处理有多个端点时的点击事件
        function handleMultiHintClick(event, rect) {
            showHintSelectionDialog(validHints).then(selectedHint => {
                let posx, posy;
                
                if (selectedHint) {
                    // 用户选择了一个端点
                    posx = parseFloat(selectedHint.dataset.x);
                    posy = parseFloat(selectedHint.dataset.y);
                } else {
                    // 用户取消选择，使用原始点击位置
                    posx = parseInt(event.clientX - rect.left);
                    posy = parseInt(event.clientY - rect.top);
                    inzone = false;
                }
                
                // 继续处理点击事件
                processMapClick(posx, posy, selectedHint || (inzone ? closestHint : null));
            });
        }

        // 处理地图点击的核心逻辑
        function processMapClick(x, y, connectedHint) {
            const posx = x;
            const posy = y;

            if (currentMode === 'road') {
                if (!isDrawingRoad) {
                    // 设置起点
                    startPoint = { x: posx, y: posy };
                    StartconnectedFrom = connectedHint;
                    // 显示起点标记
                    startPointElement.style.left = `${posx}px`;
                    startPointElement.style.top = `${posy}px`;
                    startPointElement.classList.remove('hidden');
                    statusIndicator.innerHTML = '<i class="fa fa-circle text-blue-500 mr-1"></i>已设置起点 - 请点击设定道路终点';
                    isDrawingRoad = true;
                } else {
                    // 设置终点并绘制道路
                    isDrawingRoad = false; // 重置绘制中标志
                    endPoint = { x: posx, y: posy };
                    // 显示终点标记
                    endPointElement.style.left = `${posx}px`;
                    endPointElement.style.top = `${posy}px`;
                    endPointElement.classList.remove('hidden');
                    
                    EndconnectedTo = connectedHint;
                    
                    // 后续绘制道路的代码保持不变...
                    // 计算道路宽度
                    const totalLanes = roadLeftLanes + roadRightLanes;
                    
                    const width = totalLanes * 3.75 + 5 * 2; // 车道宽3.75 + 路肩宽5*2
                    
                    // 创建道路对象
                    const roadId = nextRoadId++;
                    roadIDgeneration++;
                    
                    roads.push({
                        id: roadId,
                        start: startPoint,
                        end: endPoint,
                        startalignref:[],
                        endalignref:[],
                        controlPoint1: [0,0], // 第一个控制点
                        controlPoint2: [0,0], // 第二个控制点
                        curvature: curvature,
                        width: width,
                        totalLanes:totalLanes,
                        roadcenterline:[],
                        direction: roadDirection,
                        leftLanes: roadLeftLanes,
                        rightLanes: roadRightLanes,
                        leftlanecountchange:'none',
                        rightLaneCountChange:'none',
                        lanes:[],
                        drivingside: roadDirection === 'one-way' ? 'right' : 'both',
                        leftcurbelim: [0,8001],
                        rightcurbelim: [0,8001],
                        shapecutting:0,
                        lanemarkers:[],
                        roadedge:[],
                        roadedgeuncut:[],
                        stopLines:[],
                        arrows:[],
                        trafficlights:[],
                        connectionFrom:[],
                        connectionTo:[],
                        startalignment:"center-align",
                        endalignment:"center-align",
                        roadpatch:[],
                        roadshape:0,
                        leftboundshape:[],
                        rightboundshape:[],
                        roadclip:0,
                        selected: false,
                        startHeight:0,
                        endHeight:0,
                        midHeight:0,
                    });
                    
                    if (StartconnectedFrom){
                        connection_info ={
                            from_type: `${StartconnectedFrom.dataset.type}`,
                            from_id: parseInt(StartconnectedFrom.dataset.road),
                            from_border:`${StartconnectedFrom.dataset.end}`,
                            to_type: `road`,
                            to_id: roadIDgeneration,
                            to_border:"start",
                            points: [StartconnectedFrom.dataset.x, StartconnectedFrom.dataset.y]
                        }
                        connections.push(connection_info);
                        getConnectionInfo(connection_info);
                    }

                    // 若当前线段末端有关联
                    if (EndconnectedTo){
                        connection_info ={
                            from_type: `road`,
                            from_id: roadIDgeneration,
                            from_border:"end",
                            to_type: `${EndconnectedTo.dataset.type}`,
                            to_id: parseInt(EndconnectedTo.dataset.road),
                            to_border:`${EndconnectedTo.dataset.end}`,
                            points: [EndconnectedTo.dataset.x, EndconnectedTo.dataset.y],
                        }
                        connections.push(connection_info);
                        getConnectionInfo(connection_info);
                    }
                    drawsingleroad(startPoint, endPoint, roadId);
                    updateRoadInfo();
                    updateEndpointHints();
                    // 添加道路边界交错检测
                    checkRoadEdgeIntersections();
                    redrawAllRoads();
                    
                    // 重置道路绘制状态，添加短暂延迟防止快速点击
                    setTimeout(() => {
                        resetRoadDrawing();
                    }, 500); // 500ms延迟
                }
            } else if (currentMode === 'intersection') {
                // 放置路口
                placeIntersection(posx, posy);
                updateEndpointHints();
            }
        }
                
        // 文件选择变化处理函数
        function handleMapFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    // 解析JSON文件
                    const mapSceneData = JSON.parse(e.target.result);
                    if (mapSceneData.DataType !== 'MapProject'){
                        showNotification('加载地图文件失败，请检查文件格式,文件类型必须为XXX_Project', 'error');
                        return;
                    }
                    // 清空现有数据
                    clearMap();
                    
                    // 导入数据
                    importMapSceneData(mapSceneData);
                    
                    // 重新绘制所有道路
                    redrawAllRoads();
                    
                    // 更新UI
                    updateRoadInfo();
                    updateEndpointHints();
                    
                    // 显示成功提示
                    showNotification('道路场景加载成功', 'success');
                    } catch (error) {
                    console.error('加载地图文件失败:', error);
                    showNotification('加载地图文件失败，请检查文件格式', 'error');
                    }
                };
            reader.readAsText(file);
            
            // 重置文件输入，以便可以重复选择同一个文件
            event.target.value = '';
            }

        // 清空所有数据
        function clearAllData() {
            // 清空roads数组
            roads = [];
            
            // 清空intersections数组
            intersections = [];
            
            // 清空connections数组
            connections = [];
        
            // 清空SVG画布
            while (mapSvg.firstChild) {
                if (!['defs', 'style'].includes(mapSvg.firstChild.tagName.toLowerCase())) {
                mapSvg.removeChild(mapSvg.firstChild);
                } else {
                mapSvg.firstChild = mapSvg.firstChild.nextSibling;
                }
        }
        
        // 隐藏起点和终点标记
        startPointElement.classList.add('hidden');
        endPointElement.classList.add('hidden');
        
        // 重置绘制状态
        resetRoadDrawing();
    }

        // 导入地图场景数据（直接使用完整数据）
        function importMapSceneData(mapSceneData) {
            // 直接使用导入的roads数据，不进行选择性处理
            if (mapSceneData.roads && Array.isArray(mapSceneData.roads)) {
                roads = mapSceneData.roads;
                
                // 更新下一个道路ID
                if (roads.length > 0) {
                nextRoadId = Math.max(...roads.map(r => r.id)) + 1;
                roadIDgeneration = nextRoadId - 1;
                }
            }
            
            // 直接使用导入的intersections数据
            if (mapSceneData.intersections && Array.isArray(mapSceneData.intersections)) {
                intersections = mapSceneData.intersections;
            }
            
            // 直接使用导入的connections数据
            if (mapSceneData.connections && Array.isArray(mapSceneData.connections)) {
                connections = mapSceneData.connections;
            }
        }
        
        function getConnectionInfo(connectioninfo){
            
            if (connectioninfo.to_type == "intersection"){
                targetto = intersections.find(i => i.id === connectioninfo.to_id);
            }else{
                targetto = roads.find(i => i.id === connectioninfo.to_id);
            }
            
            if(connectioninfo.from_type == "intersection"){
                targetfrom = intersections.find(i => i.id === connectioninfo.from_id);
            }else{
                targetfrom = roads.find(i => i.id === connectioninfo.from_id);
            }

            targetto.connectionFrom.push({
                from_type: connectioninfo.from_type,
                from_id: connectioninfo.from_id,
                from_border:connectioninfo.from_border,
                points: connectioninfo.points,
            })
            targetfrom.connectionTo.push({
                to_type: connectioninfo.to_type,
                to_id: connectioninfo.to_id,
                to_border:connectioninfo.to_border,
                points: connectioninfo.points,
            })

            if (connectioninfo.from_border === "end" && targetfrom.endalignref.length===0){
                targetfrom.endalignref = {
                    id:connectioninfo.to_id,
                    vertice:connectioninfo.to_border,
                    type:connectioninfo.to_type,
                    points:connectioninfo.points
                }
            }else if(connectioninfo.from_border === "start" && targetfrom.startalignref.length===0){
                targetfrom.startalignref = {
                    id:connectioninfo.to_id,
                    vertice:connectioninfo.to_border,
                    type:connectioninfo.to_type,
                    points:connectioninfo.points
                }
            }

            if (connectioninfo.to_border == "end" && targetto.endalignref.length === 0){
                targetto.endalignref = {
                    id:connectioninfo.from_id,
                    vertice:connectioninfo.from_border,
                    type:connectioninfo.from_type,
                    points:connectioninfo.points
                }
            }else if(connectioninfo.to_border == "start" && targetto.startalignref.length === 0){
                targetto.startalignref = {
                    id:connectioninfo.from_id,
                    vertice:connectioninfo.from_border,
                    type:connectioninfo.from_type,
                    points:connectioninfo.points
                }
            }
            // console.log("Let check it now",targetto) 
        }

        function resetelinimation(){
            
            roads.forEach(road => {
                road.leftcurbelim = [0,8001];
                road.rightcurbelim = [0,8001];
                road.roadpatch = [];
                road.shapecutting = 0;
                }
            )
        }

        // 基础版（仅处理非负整数）
        function isEven(num) {
            return num % 2 === 0; // 偶数返回 true，奇数返回 false
        }

        function isOdd(num) {
            return num % 2 !== 0; // 奇数返回 true，偶数返回 false
        }
               
        function hasCommonElement(arrayA, arrayB, arrayC) {
            // 合并arrayB和arrayC为一个新数组
            const mergedArray = [...arrayB, ...arrayC]; // 或者使用 arrayB.concat(arrayC)
            // 检查arrayA中的每个元素是否存在于合并后的数组中
            for (const element of arrayA) {
                if (mergedArray.includes(element)) {
                    return true;
                }
            }
            
            // 没有找到共同元素
            return false;
        }

        function hasCommonElement2(arrayA, arrayB) {
            // 合并arrayB和arrayC为一个新数组
            // 检查arrayA中的每个元素是否存在于合并后的数组中
            for (const element of arrayA) {
                if (arrayB.includes(element)) {
                    return true;
                }
            }
            
            // 没有找到共同元素
            return false;
        }

        function fetchconnectionlist(connections,type){
            let connectionlist = [];
            connections.forEach(connection => {
                if (type == "from"){
                    connectionlist.push(connection.from_id)
                }else(
                    connectionlist.push(connection.to_id)
                )
            })
            return connectionlist;
        }

        function fetchconnectionlist2(connections,type){
            let connectionlist = [];
            connections.forEach(connection => {
                if (type == "from"){
                    connectionlist.push(`${connection.from_id}${connection.from_border}`)
                }else(
                    connectionlist.push(`${connection.to_id}${connection.to_border}`)
                )
            })
            return connectionlist;
        }

        // 添加重新渲染所有道路的函数
        function redrawAllRoads() {

            // 清空SVG容器
            roadSvg.innerHTML = '';
            roadnumberSvg.innerHTML = '';
            intersectSvg.innerHTML = '';
            
            // 重新绘制所有道路
            roads.forEach(road => {
                if (road.start && road.end) {
                    drawRoadShape(road.start, road.end, road.id);
                }
            });

                        // 重新绘制所有道路
            roads.forEach(road => {
                if (road.start && road.end) {
                    drawRoadelement(road.start, road.end, road.id);
                }
            });
            // 重新绘制所有路口（如果有）
            intersections.forEach(intersection => {
                if (intersection.id) {
                    drawIntersection(intersection.x,intersection.y,intersection.size,intersection.connectionPoints,intersection.id);
                }
            });
        }
        
        // 添加道路边界交错检测功能
        function checkRoadEdgeIntersections() {
            const intersections = [];

            // 遍历所有道路对，检查它们的路沿是否有交点
            for (let i = 0; i < roads.length; i++) {
                for (let j = i + 1; j < roads.length; j++) {
                    const road1 = roads[i];
                    const road2 = roads[j];

                    const road1startconnectionsreal = fetchconnectionlist2(road1.connectionFrom,"from");
                    const road2startconnectionsreal = fetchconnectionlist2(road2.connectionFrom,"from");
                    const road1endconnectionsreal = fetchconnectionlist2(road1.connectionTo,"to");
                    const road2endconnectionsreal = fetchconnectionlist2(road2.connectionTo,"to");

                    road1headandroad2head = hasCommonElement2(road1startconnectionsreal,road2startconnectionsreal);
                    road1headandroad2tail = hasCommonElement2(road1startconnectionsreal,road2endconnectionsreal);
                    road1tailandroad2tail = hasCommonElement2(road1endconnectionsreal,road2endconnectionsreal);
                    road1tailandroad2head = hasCommonElement2(road1endconnectionsreal,road2startconnectionsreal);
                    road1shaping = "none";

                    if(road1headandroad2head||road1headandroad2tail||road1tailandroad2tail||road1tailandroad2head){
                        linkage = true;
                        if(road1headandroad2head){
                            road1cutting = "head";
                            road2cutting = "head";
                        }else if(road1headandroad2tail){
                            road1cutting = "head";
                            road2cutting = "tail";
                        }else if(road1tailandroad2head){
                            road1cutting = "tail";
                            road2cutting = "head";
                        }else if(road1tailandroad2tail){
                            road1cutting = "tail";
                            road2cutting = "tail";
                        }}
                    else{
                        linkage = false;
                        }
                    
                    // 只检查已经绘制完成并具有路沿数据的道路
                    if (!road1.roadedge || !road2.roadedge) continue;
                    
                    // 检查road1的每条路沿与road2的每条路沿是否相交f
                    for (let re1 = 0; re1 < road1.roadedge.length; re1++) {
                        for (let re2 = 0; re2 < road2.roadedge.length; re2++) {
                            const edge1 = road1.roadedgeuncut[re1];
                            const edge2 = road2.roadedgeuncut[re2];
                            // 检查两条路沿线段之间的交点
                            if (edge1.points && edge2.points) {
                                if (linkage){
                                    console.log("road number",road1.id, "and road number", road2.id, "is intersected")
                                    const map_patch =[];
                                    const edgeIntersections = findEdgeIntersections(edge1.points, edge2.points);
                                    if (edgeIntersections[0] && edgeIntersections[1]){
                                        road1todeal = roads.find(i=>i.id === road1.id);
                                        // 找到了intersection在每一根路上的每一条边上的具体位置，根据交叉的端点进行剪裁赋值
                                        if (re1 == 0){ //若发现的边是road1的第一条边,则为左侧边缘需要修改
                                            if (road1cutting == "head"){ // 若发现road1的需要裁剪的是头部，则放入第0项
                                                // road1todeal.leftcurbelim[0] = edgeIntersections[0];
                                                if(edgeIntersections[0]>road1todeal.leftcurbelim[0]){road1todeal.leftcurbelim[0] = edgeIntersections[0];
                                                    point1 = road1todeal.roadedgeuncut[0].samplingPoints[road1todeal.leftcurbelim[0]]
                                                    point2 = road1todeal.roadedgeuncut[1].samplingPoints[road1todeal.rightcurbelim[0]]
                                                }
                                            }else{// 若发现road1的需要裁剪的是头部，则放入第1项
                                                // road1todeal.leftcurbelim[1] = edgeIntersections[0];
                                                if(edgeIntersections[0]<road1todeal.leftcurbelim[1]){road1todeal.leftcurbelim[1] = edgeIntersections[0];
                                                point1 = road1todeal.roadedgeuncut[0].samplingPoints[road1todeal.leftcurbelim[1]===8001?road1todeal.roadedgeuncut[0].samplingPoints.length-1:road1todeal.leftcurbelim[1]]
                                                point2 = road1todeal.roadedgeuncut[1].samplingPoints[road1todeal.rightcurbelim[1]===8001?road1todeal.roadedgeuncut[1].samplingPoints.length-1:road1todeal.rightcurbelim[1]]}
                                            }
                                        }else{
                                            // road1todeal.rightcurbelim = edgeIntersections[0]; 
                                            if (road1cutting == "head"){ // 若发现road1的需要裁剪的是头部，则放入第0项
                                                // road1todeal.rightcurbelim[0] = edgeIntersections[0];
                                                if(edgeIntersections[0]>road1todeal.rightcurbelim[0]){road1todeal.rightcurbelim[0] = edgeIntersections[0];
                                                point1 = road1todeal.roadedgeuncut[0].samplingPoints[road1todeal.leftcurbelim[0]]
                                                point2 = road1todeal.roadedgeuncut[1].samplingPoints[road1todeal.rightcurbelim[0]]}
                                            }else{// 若发现road1的需要裁剪的是头部，则放入第1项
                                                // road1todeal.rightcurbelim[1] = edgeIntersections[0];
                                                if(edgeIntersections[0]<road1todeal.rightcurbelim[1]){road1todeal.rightcurbelim[1] = edgeIntersections[0];
                                                point1 = road1todeal.roadedgeuncut[0].samplingPoints[road1todeal.leftcurbelim[1]===8001?road1todeal.roadedgeuncut[0].samplingPoints.length-1:road1todeal.leftcurbelim[1]]
                                                point2 = road1todeal.roadedgeuncut[1].samplingPoints[road1todeal.rightcurbelim[1]===8001?road1todeal.roadedgeuncut[1].samplingPoints.length-1:road1todeal.rightcurbelim[1]]}
                                            }

                                        }
                                        const roadIndex = roads.findIndex(r => r.id === road1.id);
                                        road1todeal.shapecutting = 0;
                                        road2todeal = roads.find(i=>i.id === road2.id);
                                        if (re2 == 0){
                                            // road2todeal.leftcurbelim = edgeIntersections[1];
                                            if (road2cutting == "head"){ // 若发现road2的需要裁剪的是头部，则放入第0项
                                                if (edgeIntersections[1]>road2todeal.leftcurbelim[0]){road2todeal.leftcurbelim[0] = edgeIntersections[1];
                                                point3 = road2todeal.roadedgeuncut[0].samplingPoints[road2todeal.leftcurbelim[0]]
                                                point4 = road2todeal.roadedgeuncut[1].samplingPoints[road2todeal.rightcurbelim[0]]}
                                            }else{// 若发现road2的需要裁剪的是头部，则放入第1项
                                                if(edgeIntersections[1]<road2todeal.leftcurbelim[1]){road2todeal.leftcurbelim[1] = edgeIntersections[1];
                                                point3 = road2todeal.roadedgeuncut[0].samplingPoints[road2todeal.leftcurbelim[1]===8001?road2todeal.roadedgeuncut[0].samplingPoints.length-1:road2todeal.leftcurbelim[1]]
                                                point4 = road2todeal.roadedgeuncut[1].samplingPoints[road2todeal.rightcurbelim[1]===8001?road2todeal.roadedgeuncut[1].samplingPoints.length-1:road2todeal.rightcurbelim[1]]}
                                            }

                                        }else{
                                            // road2todeal.rightcurbelim = edgeIntersections[1]; 
                                            if (road2cutting == "head"){ // 若发现road2的需要裁剪的是头部，则放入第0项
                                                if (edgeIntersections[1]>road2todeal.rightcurbelim[0]){road2todeal.rightcurbelim[0] = edgeIntersections[1];
                                                point3 = road2todeal.roadedgeuncut[0].samplingPoints[road2todeal.leftcurbelim[0]]
                                                point4 = road2todeal.roadedgeuncut[1].samplingPoints[road2todeal.rightcurbelim[0]]}
                                            }else{// 若发现road2的需要裁剪的是头部，则放入第1项
                                                if (edgeIntersections[1]<road2todeal.rightcurbelim[1]){road2todeal.rightcurbelim[1] = edgeIntersections[1];
                                                point3 = road2todeal.roadedgeuncut[0].samplingPoints[road2todeal.leftcurbelim[1]===8001?road2todeal.roadedgeuncut[0].samplingPoints.length-1:road2todeal.leftcurbelim[1]]
                                                point4 = road2todeal.roadedgeuncut[1].samplingPoints[road2todeal.rightcurbelim[1]===8001?road2todeal.roadedgeuncut[1].samplingPoints.length-1:road2todeal.rightcurbelim[1]]}
                                            }
                                        }
                                        const roadIndex2 = roads.findIndex(r => r.id === road2.id);
                                        road2todeal.shapecutting = 0;
                                    }
                                }else{
                                    console.log("road number",road1.id, "and road number", road2.id, "is overlapped")
                                }
                            }
                            
                        }
                    }
                }
            }
            
            // 绘制所有交点
            // drawIntersectionPoints(intersections);
        }
        
        // 查找两条路沿之间的所有交点
        function findEdgeIntersections(points1, points2) {
            const intersections = [];
            let nearestpoint1;
            let nearestpoint2;
            let found_intersection;

            // 遍历第一条路沿的所有线段
            for (let i = 0; i < points1.length - 1; i++) {
                const p1 = points1[i];
                const p2 = points1[i + 1];
                
                // 遍历第二条路沿的所有线段
                for (let j = 0; j < points2.length - 1; j++) {
                    const p3 = points2[j];
                    const p4 = points2[j + 1];
                    
                    // 计算两条线段的交点
                    const intersection = findLineIntersection(p1, p2, p3, p4);
                    
                    if (intersection){
                        found_intersection = intersection;
                        nearestpoint1 = findNearestPoint(intersection, points1);
                        nearestpoint2 = findNearestPoint(intersection, points2);
                        if (nearestpoint1 && nearestpoint2) {
                            intersections.push(intersection);
                        }
                    }
                    // 如果有交点且在两条线段
                }
            }
            return [nearestpoint1,nearestpoint2,found_intersection];
        }

        function calculateDistance(point1, point2) {
            const dx = point2.x - point1.x;
            const dy = point2.y - point1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function findNearestPoint(pointA, pointsArray) {
            if (!pointsArray || pointsArray.length === 0) {
                return null; // 如果数组为空，返回null
            }
            
            let nearestPoint = pointsArray[0];
            let minDistance = calculateDistance(pointA, nearestPoint);
            let position = 0;
            
            // 遍历数组中的所有点，找到距离最小的点
            for (let i = 0; i < pointsArray.length; i++) {
                const currentPoint = pointsArray[i];
                const currentDistance = calculateDistance(pointA, currentPoint);
                
                if (currentDistance < minDistance) {
                    minDistance = currentDistance;
                    nearestPoint = currentPoint;
                    position = i;
                }
            }
            if(position == 0 || position == pointsArray.length-1){
                return null
            }else{
                return position;
            }
        }
        
        // 计算两条线段的交点
        function findLineIntersection(p1, p2, p3, p4) {
            // 计算分母
            const denominator = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            
            // 如果分母为0，线段平行，无交点
            if (denominator === 0) return null;
            
            // 计算分子
            const numeratorX = (p1.x * p2.y - p1.y * p2.x) * (p3.x - p4.x) - (p1.x - p2.x) * (p3.x * p4.y - p3.y * p4.x);
            const numeratorY = (p1.x * p2.y - p1.y * p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x * p4.y - p3.y * p4.x);
            
            // 计算交点坐标
            const x = numeratorX / denominator;
            const y = numeratorY / denominator;
            
            // 检查交点是否在线段上
            if (
                x >= Math.min(p1.x, p2.x) - 0.1 && x <= Math.max(p1.x, p2.x) + 0.1 &&
                y >= Math.min(p1.y, p2.y) - 0.1 && y <= Math.max(p1.y, p2.y) + 0.1 &&
                x >= Math.min(p3.x, p4.x) - 0.1 && x <= Math.max(p3.x, p4.x) + 0.1 &&
                y >= Math.min(p3.y, p4.y) - 0.1 && y <= Math.max(p3.y, p4.y) + 0.1
            ) {
                return { x, y };
            }
            
            return null;
        }
        

        function calculateDirectionFromConnectedPoint(connectedPoint,pointtype,refline,connectiontype) {
            
            const type = connectiontype == "start" ? connectedPoint.type : connectedPoint.type; //用于区分是绘制的是起点还是中点
            const id = connectiontype == "start" ? connectedPoint.id : connectedPoint.id;
            const x = parseFloat(connectedPoint.points[0]);
            const y = parseFloat(connectedPoint.points[1]);
            
            if (type === 'road') {
                const road = roads.find(r => r.id === parseInt(id));
                if (road) {
                    // 确定关联点是道路的起点还是终点
                    const isStartPoint = pointtype == "start" ? true : false;
                    const isEndPoint = pointtype == "end" ? true : false;
                    if (true) {
                        // 使用道路的车道线采样点计算方向，这样对于弯曲道路更准确
                        // 尝试获取最靠近连接点的车道线
                        const centerLane = findCenterLane(road);
                        if (refline.length>0) {
                            const samplingPoints = refline;
                            if (isStartPoint || isEndPoint) {
                                // 获取连接点在采样点中的位置
                                let targetIndex = isStartPoint ? 0 : samplingPoints.length - 1;
                                
                                // 对于弯曲道路，使用多个点计算切线方向
                                // 使用最后2-3个点（对于终点）或前2-3个点（对于起点）来计算切线
                                if (samplingPoints.length >= 3) {
                                    let p1, p2, p3;
                                    if (isStartPoint) {
                                        p1 = samplingPoints[0];
                                        p2 = samplingPoints[1];
                                        p3 = samplingPoints[Math.min(2, samplingPoints.length - 1)];
                                        // 使用前三个点计算切线方向
                                        return calculateTangentDirection(p1, p2, p3, true);
                                    } else {
                                        p1 = samplingPoints[Math.max(samplingPoints.length - 3, 0)];
                                        p2 = samplingPoints[samplingPoints.length - 2];
                                        p3 = samplingPoints[samplingPoints.length - 1];
                                        // 使用最后三个点计算切线方向
                                        return calculateTangentDirection(p1, p2, p3, false);
                                    }
                                } else if (samplingPoints.length >= 2) {
                                    // 如果采样点不足3个，使用简单的直线方向
                                    const p1 = samplingPoints[0];
                                    const p2 = samplingPoints[samplingPoints.length - 1];
                                    return isStartPoint ? 
                                        { dx: p2.x - p1.x, dy: p2.y - p1.y } : 
                                        { dx: p1.x - p2.x, dy: p1.y - p2.y };
                                }
                            }
                        }
                    }
                    
                    // 如果无法获取车道线采样点，回退到原始方法
                    if (isStartPoint) {
                        return { dx: road.end.x - road.start.x, dy: road.end.y - road.start.y };
                    } else if (isEndPoint) {
                        return { dx: road.start.x - road.end.x, dy: road.start.y - road.end.y };
                    }
                }
            } else if (type === 'intersection') {
                const intersection = intersections.find(i => i.id === parseInt(id));
                if (intersection) {
                    return { dx: intersection.x - x, dy: intersection.y - y };
                }
            }
            
            return null;
        }

        // 辅助函数：计算三个点的切线方向
        function calculateTangentDirection(p1, p2, p3, isStart) {
            // 计算从p1到p2和从p2到p3的向量
            const v1x = p2.x - p1.x;
            const v1y = p2.y - p1.y;
            const v2x = p3.x - p2.x;
            const v2y = p3.y - p2.y;
            
            // 计算向量长度
            const len1 = Math.sqrt(v1x * v1x + v1y * v1y);
            const len2 = Math.sqrt(v2x * v2x + v2y * v2y);
            
            // 计算单位向量
            const u1x = len1 > 0 ? v1x / len1 : 0;
            const u1y = len1 > 0 ? v1y / len1 : 0;
            const u2x = len2 > 0 ? v2x / len2 : 0;
            const u2y = len2 > 0 ? v2y / len2 : 0;
            
            // 平均两个单位向量以获得平滑的切线方向
            let avgX, avgY;
            if (isStart) {
                // 对于起点，更侧重第二个向量
                avgX = 0.3 * u1x + 0.7 * u2x;
                avgY = 0.3 * u1y + 0.7 * u2y;
            } else {
                // 对于终点，更侧重第一个向量
                avgX = 0.7 * u1x + 0.3 * u2x;
                avgY = 0.7 * u1y + 0.3 * u2y;
            }
            
            // 归一化平均向量
            const avgLen = Math.sqrt(avgX * avgX + avgY * avgY);
            if (avgLen > 0) {
                avgX /= avgLen;
                avgY /= avgLen;
            }
            if (isStart){
                return { dx: avgX, dy: avgY };
            }
            else{
                return { dx: -avgX, dy: -avgY };
            }
        }

        // 辅助函数：查找道路的中心车道
        function findCenterLane(road) {
            if (!road.lanes || road.lanes.length === 0) return null;
            
            // 找到最靠近道路中心线的车道
            const centerIndex = Math.floor(road.lanes.length / 2);
            return road.lanes[centerIndex];
        }

        function determineroadgeometrie(road){
            const startalignmentmode = road.startalignment;
            const endalignmentmode = road.endalignment;
            const currenttotallanes = road.totalLanes;
            const startPoint = road.start;
            const endPoint = road.end;
            let fromalignment;
            let toalignment;
            let newpoint_start;
            let endalignment;
            let newpoint_end;
            let fromalignlanenumber;
            let fromlanetocenter;
            let tolanetocenter;
            let frommarker;
            let tomarker;
            let Startconnection;
            let Endconnection;


            // 中心定位，即中心线对应中心线

            //左侧定位，即左侧线对应左侧线，根据左侧对齐计算中心线差距，前继道路中心线到左边缘距离为-fromhalfwidth，当前为-currenthalfwidth。offset则为（-fromhalfwidth）-（-currenthalfwidth）
            
            // 右侧定位，即右侧先对应右侧先，则为
            Startconnection = road.startalignref;
            Endconnection = road.endalignref;
            let fromalignoffset = 0;
            let fromalignref =[];
            let toalignoffset = 0;
            let toalignref =[];
            if(Startconnection.type == "road"){
                
                const fromroad = roads.find(i => i.id === parseInt(Startconnection.id)); //获取起点关联道路数据

                const fromtotoallanes = fromroad.totalLanes; //获取起点关联道路总车道数
                const fromroadhalfwidth = fromroad.width/2;
                const currentroadhalfwidth = road.width/2;
                const fromroadcenterline = fromroad.roadcenterline;

                if (startalignmentmode =="right-align"){  //若为右对齐
                    //计算对齐偏移量
                    fromalignoffset = fromroadhalfwidth - currentroadhalfwidth;
                    //计算新的起点
                    fromalignref = calculateOffsetPoints(fromroadcenterline,fromalignoffset)
                }else if(startalignmentmode =="left-align"){
                    fromalignoffset = -(fromroadhalfwidth - currentroadhalfwidth);
                    //计算新的起点
                    fromalignref = calculateOffsetPoints(fromroadcenterline,fromalignoffset)
                }else {
                    fromalignref = calculateOffsetPoints(fromroadcenterline,fromalignoffset)
                }

                //此为该道路的起点坐标，根据和关联道的关联线顶点定义
                //需要判断关联道路选取的点是起点还是终点（哪一段）

                if (Startconnection.vertice == "end"){
                    newpoint_start = fromalignref[fromalignref.length-1];
                }else{
                    newpoint_start = fromalignref[0];
                }
                startPoint.x = newpoint_start.x;
                startPoint.y = newpoint_start.y;
                Startconnection.points[0] = startPoint.x;
                Startconnection.points[1] = startPoint.y;

            }

            if(Endconnection.type == "road"){
                const toroad = roads.find(i => i.id === parseInt(Endconnection.id));
                const tototoallanes = toroad.totalLanes;
                const toroadhalfwidth = toroad.width/2;
                const currentroadhalfwidth = road.width/2;
                const toroadcenterline = toroad.roadcenterline;

                if (endalignmentmode =="right-align"){  //若为右对齐
                    //计算对齐偏移量
                    toalignoffset = toroadhalfwidth - currentroadhalfwidth;
                    //计算新的起点
                    toalignref = calculateOffsetPoints(toroadcenterline,toalignoffset)
                }else if(endalignmentmode =="left-align"){
                    toalignoffset = -(toroadhalfwidth - currentroadhalfwidth);
                    //计算新的起点
                    toalignref = calculateOffsetPoints(toroadcenterline,toalignoffset)
                }else {
                    toalignref = calculateOffsetPoints(toroadcenterline,toalignoffset)
                }
                //需要判断关联道路选取的点是起点还是终点（哪一段）
                if (Endconnection.vertice == "end"){
                    newpoint_end = toalignref[toalignref.length-1];
                }else{
                    newpoint_end = toalignref[0];
                }
                endPoint.x = newpoint_end.x;
                endPoint.y = newpoint_end.y;
                Endconnection.points[0] = endPoint.x;
                Endconnection.points[1] = endPoint.y

            }

            // 优化：计算关联点的方向，特别针对弯曲道路进行平滑处理

            // 获取起点关联点的方向（如果有）
            const startDirection = Startconnection.id? calculateDirectionFromConnectedPoint(Startconnection, Startconnection.vertice,fromalignref,"start") : null;

            // 获取终点关联点的方向（如果有）
            const endDirection = Endconnection.id? calculateDirectionFromConnectedPoint(Endconnection, Endconnection.vertice ,toalignref,"end") : null;

            if (startDirection && endDirection) {
                // 同时有起点和终点方向约束
                // 计算起点方向的单位向量
                const startLength = Math.sqrt(startDirection.dx * startDirection.dx + startDirection.dy * startDirection.dy);
                const startUnitX = startDirection.dx / startLength;
                const startUnitY = startDirection.dy / startLength;
                
                // 计算终点方向的单位向量（根据您的测试，不需要反向）
                const endLength = Math.sqrt(endDirection.dx * endDirection.dx + endDirection.dy * endDirection.dy);
                const endUnitX = endDirection.dx / endLength;
                const endUnitY = endDirection.dy / endLength;
                
                // 计算两个控制点，使道路在起点和终点处符合方向约束
                // 控制点距离起点/终点的距离（可调整）
                const roadLength = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));
                const controlDistance = Math.min(300, roadLength / 2);
                // 第一个控制点：从起点沿起点方向延伸
                const control1X = startPoint.x - startUnitX * controlDistance;
                const control1Y = startPoint.y - startUnitY * controlDistance;
                
                // 第二个控制点：从终点沿终点方向延伸
                const control2X = endPoint.x - endUnitX * controlDistance; // 注意这里是减去，因为我们要向道路内部延伸
                const control2Y = endPoint.y - endUnitY * controlDistance;
                
                // 直接设置控制点，不改变起点和终点
                controlPoints = { 
                    control1: { x: control1X, y: control1Y }, 
                    control2: { x: control2X, y: control2Y } 
                };
            } else if (startDirection) {
                // 只有起点方向约束
                // 计算起点方向的单位向量
                const startLength = Math.sqrt(startDirection.dx * startDirection.dx + startDirection.dy * startDirection.dy);
                const startUnitX = startDirection.dx / startLength;
                const startUnitY = startDirection.dy / startLength;
                
                // 控制点距离
                const controlDistance = Math.min(100, Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)) / 3);
                
                // 第一个控制点：从起点沿起点方向延伸
                const control1X = startPoint.x - startUnitX * controlDistance;
                const control1Y = startPoint.y - startUnitY * controlDistance;
                
                // 第二个控制点：使用默认计算但确保平滑过渡
                const controlPointsDefault = calculateControlPoint(startPoint, endPoint, curvature);
                
                controlPoints = { 
                    control1: { x: control1X, y: control1Y }, 
                    control2: controlPointsDefault.control2 
                };
            } else if (endDirection) {
                // 只有终点方向约束
                // 计算终点方向的单位向量
                const endLength = Math.sqrt(endDirection.dx * endDirection.dx + endDirection.dy * endDirection.dy);
                const endUnitX = endDirection.dx / endLength;
                const endUnitY = endDirection.dy / endLength;
                
                // 控制点距离
                const controlDistance = Math.min(100, Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)) / 3);
                
                // 第二个控制点：从终点沿终点方向延伸（向道路内部）
                const control2X = endPoint.x - endUnitX * controlDistance;
                const control2Y = endPoint.y - endUnitY * controlDistance;
                
                // 第一个控制点：使用默认计算但确保平滑过渡
                const controlPointsDefault = calculateControlPoint(startPoint, endPoint, curvature);
                
                controlPoints = { 
                    control1: controlPointsDefault.control1, 
                    control2: { x: control2X, y: control2Y } 
                };
            } else {
                // 没有方向约束，使用默认计算
                controlPoints = calculateControlPoint(startPoint, endPoint, curvature);
            }
            roadgeo = {startPoint,endPoint,controlPoints};
            return roadgeo
        }

        // 放置路口
        function placeIntersection(x, y) {
            const intersectionId = nextIntersectionId++;
            const size = 40; // 路口大小为20x20
            
            // 根据选中的路口类型设置连通点
            let connectionPoints = [];
            
            if (selectedIntersectionType === 'cross') {
                // 十字路口：四条边的中点
                connectionPoints = [
                    { x: x, y: y - size/2 }, // 上
                    { x: x + size/2, y: y }, // 右
                    { x: x, y: y + size/2 }, // 下
                    { x: x - size/2, y: y }  // 左
                ];
            } else if (selectedIntersectionType === 't-junction') {
                // 丁字路口：三条边
                connectionPoints = [
                    { x: x, y: y - size/2 }, // 上
                    { x: x + size/2, y: y }, // 右
                    { x: x - size/2, y: y }  // 左
                ];
            } else if (selectedIntersectionType === 'straight') {
                // 直行路口：两条非相邻边
                connectionPoints = [
                    { x: x, y: y - size/2 }, // 上
                    { x: x, y: y + size/2 }  // 下
                ];
            }
            
            // 保存路口数据
            intersections.push({
                id: intersectionId,
                x: x,
                y: y,
                size: size,
                type: selectedIntersectionType,
                connectionPoints: connectionPoints,
                connectionFrom: [],
                connectionTo: [],
            });
            
            // 绘制路口
            drawIntersection(x, y, size, connectionPoints,intersectionId);
        }
        
        // 绘制路口
        function drawIntersection(x, y, size, connectionPoints,intersectionId) {
            // 创建路口组
            const intersectionGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            intersectionGroup.setAttribute('class', 'intersection');
            // 为路口添加唯一标识符
            intersectionGroup.setAttribute('data-intersection-id', intersectionId);
            
            // 绘制路口主体（长方形）
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', x - size/2);
            rect.setAttribute('y', y - size/2);
            rect.setAttribute('width', size);
            rect.setAttribute('height', size);
            rect.setAttribute('fill', '#AAAAAA');
            // rect.setAttribute('stroke', 'black');
            // rect.setAttribute('stroke-width', '2');
            intersectionGroup.appendChild(rect);
            
            
            // 添加到SVG
            intersectSvg.appendChild(intersectionGroup);
        }
        
        function selectIntersection(intersectionId) {
            // 取消选中当前选中的道路（如果有）
            deselectIntersection();
            // 记录选中的路口ID
            selectedIntersectionId = intersectionId;
            
            // 高亮显示选中的路口
            const intersectionElement = document.querySelector(`.intersection[data-intersection-id="${intersectionId}"]`);
            if (intersectionElement) {
                intersectionElement.classList.add('intersection-selected');
                // 添加拖拽事件监听
                // intersectionElement.addEventListener('mousedown', startIntersectionDrag);
            }
            
            // 显示路口信息
            const intersection = intersections.find(i => i.id === intersectionId);
            if (intersection) {
                statusIndicator.innerHTML = `<i class="fa fa-circle text-green-500 mr-1"></i>已选中路口 - ID: ${intersectionId}, 类型: ${intersection.type}`;
                noSelectionText.classList.add('hidden');
            }
        }
        
        // 修改deselectIntersection函数，移除拖拽事件监听
        function deselectIntersection() {
            if (selectedIntersectionId !== null) {
                const intersectionElement = document.querySelector(`.intersection[data-intersection-id="${selectedIntersectionId}"]`);
                if (intersectionElement) {
                    intersectionElement.classList.remove('intersection-selected');
                    // 移除拖拽事件监听
                    // intersectionElement.removeEventListener('mousedown', startIntersectionDrag);
                }
                selectedIntersectionId = null;
                
                // 如果没有选中的道路，显示默认状态
                if (selectedRoadId === null) {
                    statusIndicator.innerHTML = '<i class="fa fa-circle text-blue-500 mr-1"></i>修改器模式 - 点击道路或路口进行编辑';
                    noSelectionText.classList.remove('hidden');
                }
            }
        }


        // 新增：拖拽路口函数
        function dragIntersection(e) {
            if (!isDraggingIntersection || draggedIntersectionId === null) return;
            
            // 阻止默认行为
            e.preventDefault();
            
            // 计算当前鼠标位置相对于SVG的坐标
            const svgRect = roadSvg.getBoundingClientRect();
            const currentX = e.clientX - svgRect.left;
            const currentY = e.clientY - svgRect.top;
            
            // 计算位移
            const dx = currentX - dragStartX;
            const dy = currentY - dragStartY;
            
            // 更新拖拽起始位置（用于下一次计算）
            dragStartX = currentX;
            dragStartY = currentY;
            
            // 查找要拖拽的路口
            const intersectionIndex = intersections.findIndex(i => i.id === draggedIntersectionId);
            if (intersectionIndex === -1) return;
            
            const intersection = intersections[intersectionIndex];
            
            // 更新路口位置
            intersection.x += dx;
            intersection.y += dy;
            
            // 更新路口连接点位置
            intersection.connectionPoints = intersection.connectionPoints.map(point => ({
                x: point.x + dx,
                y: point.y + dy
            }));
            
            // 更新SVG中的路口元素
            updateIntersectionVisual(draggedIntersectionId, intersection);
            
            // 更新与该路口连接的道路
            updateConnectedRoads(draggedIntersectionId);
        }

        // 新增：更新路口视觉元素函数
        function updateIntersectionVisual(intersectionId, intersection) {
            const intersectionElement = document.querySelector(`.intersection[data-intersection-id="${intersectionId}"]`);
            if (!intersectionElement) return;
            
            // 清空现有内容
            while (intersectionElement.firstChild) {
                intersectionElement.removeChild(intersectionElement.firstChild);
            }
            
            // 重新绘制路口
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', intersection.x - intersection.size/2);
            rect.setAttribute('y', intersection.y - intersection.size/2);
            rect.setAttribute('width', intersection.size);
            rect.setAttribute('height', intersection.size);
            rect.setAttribute('fill', '#AAAAAA');
            rect.setAttribute('stroke', '#000000');
            rect.setAttribute('stroke-width', '2');
            intersectionElement.appendChild(rect);
            
            // 绘制连接点指示
            intersection.connectionPoints.forEach((point, index) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', 5);
                circle.setAttribute('fill', '#0000FF');
                circle.setAttribute('stroke', '#FFFFFF');
                circle.setAttribute('stroke-width', '2');
                intersectionElement.appendChild(circle);
            });
        }

        // 新增：更新与路口连接的道路函数
        function updateConnectedRoads(intersectionId) {
            // 查找所有与该路口连接的道路
            roads.forEach(road => {
                // 检查道路起点是否连接到该路口
                if (road.connectedFrom && road.connectedFrom.dataset.type === 'intersection' && 
                    parseInt(road.connectedFrom.dataset.road) === intersectionId) {
                    // 找到对应的连接点
                    const intersection = intersections.find(i => i.id === intersectionId);
                    if (intersection) {
                        // 更新道路起点位置
                        const startPoint = intersection.connectionPoints.find(p => 
                            Math.abs(p.x - road.start.x) < 10 && Math.abs(p.y - road.start.y) < 10
                        ) || intersection.connectionPoints[0];
                        
                        road.start.x = startPoint.x;
                        road.start.y = startPoint.y;
                    }
                }
                
                // 检查道路终点是否连接到该路口
                if (road.connectedTo && road.connectedTo.dataset.type === 'intersection' && 
                    parseInt(road.connectedTo.dataset.road) === intersectionId) {
                    // 找到对应的连接点
                    const intersection = intersections.find(i => i.id === intersectionId);
                    if (intersection) {
                        // 更新道路终点位置
                        const endPoint = intersection.connectionPoints.find(p => 
                            Math.abs(p.x - road.end.x) < 10 && Math.abs(p.y - road.end.y) < 10
                        ) || intersection.connectionPoints[0];
                        
                        road.end.x = endPoint.x;
                        road.end.y = endPoint.y;
                    }
                }
                
                // 重绘道路
                redrawRoad(road.id);
            });
        }
                
        // 应用道路参数修改
        function applyRoadChanges() {
            choices = ["left-align","center-align","right-align"];
            if (selectedRoadId !== null) {
                const newDirection = selectedRoadDirectionSelect.value;
                const newLeftLanes = newDirection === 'two-way' ? parseInt(selectedRoadLeftLanesInput.value) : 0;
                const newRightLanes = parseInt(selectedRoadRightLanesInput.value);
                const oldLeftLanes = roads[selectedRoadId-1].leftLanes
                const oldRightLanes = roads[selectedRoadId-1].rightLanes
                const roadstartalignment = selectedRoadAlignmentStart.value;
                const roadendalignment = selectedRoadAlignmentEnd.value;
                const newStartHeight = parseFloat(selectedRoadStartHeightInput.value);
                const newEndHeight = parseFloat(selectedRoadEndHeightInput.value);

                // 获取车道减少设置

                const leftLaneCountChange = selectedRoadLeftLaneCountChangeSelect.value;
                const rightLaneCountChange = selectedRoadRightLaneCountChangeSelect.value;
                if((oldLeftLanes - newLeftLanes) !=0 ||(oldRightLanes -newRightLanes)!=0){
                    layoutchange = true;
                }else{
                    layoutchange = false;
                }
                // 获取新的曲率值
                // const newCurvature = parseFloat(document.getElementById('selected-road-curvature-input').value);
                
                // 根据车道数量计算新的道路宽度
                const totalLanes = newLeftLanes + newRightLanes;
                const newWidth = totalLanes * 3.75 + 5 * 2; // 车道宽3.75 + 路肩宽5*2
                
                // 更新道路数据
                const roadIndex = roads.findIndex(r => r.id === selectedRoadId);
                if (roadIndex !== -1) {
                    roads[roadIndex].width = newWidth;
                    roads[roadIndex].direction = newDirection;
                    roads[roadIndex].leftLanes = newLeftLanes;
                    roads[roadIndex].rightLanes = newRightLanes;
                    roads[roadIndex].drivingside = newDirection === 'one-way' ? 'right' : 'both';
                    roads[roadIndex].leftlaneCountChange = leftLaneCountChange;
                    roads[roadIndex].rightlaneCountChange = rightLaneCountChange;
                    roads[roadIndex].totalLanes = totalLanes;
                    roads[roadIndex].startalignment = roadstartalignment;
                    roads[roadIndex].endalignment = roadendalignment;
                    roads[roadIndex].startHeight = newStartHeight;
                    roads[roadIndex].endHeight = newEndHeight;
                    
                    const startroadIndex = roads.findIndex(r => r.id === roads[roadIndex].startalignref.id);
                    const startaligndirection = roads[roadIndex].startalignref.vertice;
                    const endroadIndex = roads.findIndex(r => r.id === roads[roadIndex].endalignref.id);
                    const endaligndirection = roads[roadIndex].endalignref.vertice;
                    if (startroadIndex != -1){

                        if(startaligndirection==="start"){ // 起点对齐方向为start时，更新起点对齐参考道路为当前道路的终点对齐参考道路
                            startroadconnection = roads[startroadIndex].startalignref.id;
                            // console.log("Need to put the startheight of the road ",roads[startroadIndex].id,"'s height as ",newStartHeight)
                            }
                        else if(startaligndirection==="end"){
                            startroadconnection = roads[startroadIndex].endalignref.id; }
                        else{
                            startroadconnection = 0;
                        }
                       
                        if (startroadconnection != selectedRoadId){
                            console.log("No need")
                        }else{
                            if (startaligndirection == 'end'){
                                roads[startroadIndex].endalignment = roadstartalignment;
                            }else{
                                invertchoice = 2-(choices.findIndex(c => c == roadstartalignment))
                                roads[startroadIndex].startalignment = choices[invertchoice];
                            }
                        }
                    }else{
                        console.log("No need")
                    }

                    if (endroadIndex != -1){
                        
                        if(endaligndirection==="start"){
                            endroadconnection = roads[endroadIndex].startalignref.id;}
                        else if(endaligndirection==="end"){
                                endroadconnection = roads[endroadIndex].endalignref.id; }
                       
                        if (endroadconnection != selectedRoadId){
                            console.log("No need")
                        }else{

                        if (endaligndirection == 'start'){
                            roads[endroadIndex].startalignment = roadendalignment;
                        }else{
                            invertchoice = 2-(choices.findIndex(c => c == roadendalignment))
                            roads[endroadIndex].endalignment = choices[invertchoice];
                        }}
                    }else{
                        console.log("No need")
                    }
                    
                    // 更新车道线设置
                    const colorSelects = document.querySelectorAll('.lane-marker-color');
                    const typeSelects = document.querySelectorAll('.lane-marker-type');
                    const lanedirectionSelects = document.querySelectorAll('.lane-turn-direction');

                    colorSelects.forEach(select => {
                        const index = parseInt(select.dataset.index);
                        if (roads[roadIndex].lanemarkers && roads[roadIndex].lanemarkers[index]) {
                            roads[roadIndex].lanemarkers[index].color = select.value;
                            // console.log("Her we go teh color",roads[roadIndex].lanemarkers[index].color)
                        }
                    });

                    typeSelects.forEach(select => {
                        const index = parseInt(select.dataset.index);

                        if (roads[roadIndex].lanemarkers && roads[roadIndex].lanemarkers[index]) {
                            roads[roadIndex].lanemarkers[index].type = select.value;
                        }
                    });

                    lanedirectionSelects.forEach(select => {
                        const index = parseInt(select.dataset.index);
                        if (roads[roadIndex].lanes && roads[roadIndex].lanes[index]) {
                            roads[roadIndex].lanes[index].turnDirection = select.value;
                        }
                    });
                    // 更新表单中的宽度显示
                    selectedRoadWidthInput.value = newWidth;
                    

                    
                    // 显示提示
                    showNotification('道路参数已更新', 'success');
                }
                                    // 重新绘制道路
                resetelinimation();
                // redrawRoad(roadIndex);
                checkRoadEdgeIntersections();
                redrawAllRoads();
                // 更新UI
                updateRoadInfo();            }

        }

        // 修改calculateLaneReductionOffsetPoints函数，增加道路方向参数并修复偏移逻辑
        function calculateLaneReductionOffsetPoints(centerLinePoints, offset, reducedoffset, startingdirection) {
            const offsetPoints = [];
            const laneWidth = 3.75; // 车道宽度
            for (let i = 0; i < centerLinePoints.length; i++) {
                // 计算当前点与下一点的方向向量
                const current = centerLinePoints[i];
                let dx, dy;
                
                if (i === centerLinePoints.length - 1 && i > 0) {
                    const prev = centerLinePoints[i - 1];
                    dx = current.x - prev.x;
                    dy = current.y - prev.y;
                } else if (i < centerLinePoints.length - 1) {
                    const next = centerLinePoints[i + 1];
                    dx = next.x - current.x;
                    dy = next.y - current.y;
                } else {
                    dx = 1;
                    dy = 0;
                }
                
                const length = Math.max(0.001, Math.sqrt(dx * dx + dy * dy));
                
                // 计算垂直于道路方向的单位向量
                const perpX = -dy / length;
                const perpY = dx / length;
                
                // 根据道路进度计算偏移量调整值
                const progress = i / (centerLinePoints.length - 1);
                let adjustedOffset = offset

                if (startingdirection === "start"){ //如果从起点开始，则逐步增大
                    if(progress < 0.5){
                        const t = (progress) / 0.5;
                        adjustedOffset = offset + (1-t) * (reducedoffset);
                    }else{
                        adjustedOffset = offset;
                    }
                }else if (startingdirection === "end"){
                    if(progress > 0.5){
                        const t = (progress - 0.5) / 0.5;
                        adjustedOffset = offset + t * (reducedoffset);
                    }else{
                        adjustedOffset = offset;
                    }
                } 
                
                
                // 基于调整后的偏移量计算新的点
                offsetPoints.push({
                    x: current.x + perpX * adjustedOffset,
                    y: current.y + perpY * adjustedOffset
                });
            }
            
            return offsetPoints;
        }
            
        // 在页面HTML部分，修改road-parameter-form的结构
        function updateRoadParameterForm() {            // 清空现有表单
            const roadParameterForm = document.getElementById('road-parameter-form');
            roadParameterForm.innerHTML = `
                <div class="space-y-2">
                    <button id="apply-changes" class="w-full px-4 py-2 bg-primary hover:bg-primary/90 text-white rounded-lg transition-all duration-300 flex items-center justify-center mt-4">
                        <i class="fa fa-check mr-2"></i>应用修改
                    </button>
                    <button id="move-to-top" class="w-full px-4 py-2 bg-primary hover:bg-primary/90 text-white rounded-lg transition-all duration-300 flex items-center justify-center mt-4">
                        <i class="fa fa-gear mr-2"></i>移到最上
                    </button>
                    <!-- 道路级别属性（第一层） -->
                    <div class="space-y-3 p-3 bg-gray-50 rounded-lg border border-gray-200">
                        <h4 class="text-sm font-medium text-gray-600">道路基本属性</h4>
                        
                        <!-- 道路宽度输入框（只读） -->
                        <div class="flex justify-between items-center">
                            <label class="text-sm text-gray-600">道路宽度</label>
                            <input type="number" min="1" max="50" value="10" class="width-input" id="selected-road-width-input" readonly>
                        </div>
                        
                        <!-- 道路方向选择器 -->
                        <div class="flex justify-between items-center">
                            <label class="text-sm text-gray-600">道路方向</label>
                            <select id="selected-road-direction-select" class="text-sm border rounded px-2 py-1">
                                <option value="one-way">单向</option>
                                <option value="two-way">双向</option>
                            </select>
                        </div>
                        
                        <!-- 左侧车道数量输入框 -->
                        <div class="flex justify-between items-center left-lane-container">
                            <label class="text-sm text-gray-600">左侧车道数量</label>
                            <input type="number" min="0" max="10" value="1" class="text-sm border rounded px-2 py-1" id="selected-road-left-lanes-input">
                        </div>
                        
                        <!-- 右侧车道数量输入框 -->
                        <div class="flex justify-between items-center">
                            <label class="text-sm text-gray-600">右侧车道数量</label>
                            <input type="number" min="1" max="10" value="1" class="text-sm border rounded px-2 py-1" id="selected-road-right-lanes-input">
                        </div>
                        <!-- 起点高度输入框 -->
                        <div class="flex justify-between items-center">
                            <label class="text-sm text-gray-600">起点高度</label>
                            <input type="number" min="0" max="30" value="0" class="text-sm border rounded px-2 py-1" id="selected-road-start-height-input">
                        </div>
                        <!-- 终点高度输入框 -->
                        <div class="flex justify-between items-center">
                            <label class="text-sm text-gray-600">终点高度</label>
                            <input type="number" min="0" max="30" value="0" class="text-sm border rounded px-2 py-1" id="selected-road-end-height-input">
                        </div>
                    </div>

                    <div class="flex justify-between items-center">
                        <label class="text-sm text-gray-600">右侧车道数量变化</label>
                        <select id="select-rightside-lanecountchange-selection" class="text-sm border rounded px-2 py-1">
                            <option value="none">没有变化</option>
                            <option value="reduce">车道减少</option>
                            <option value="increase">车道增加</option>
                        </select>
                    </div>
                    <div class="flex justify-between items-center">
                        <label class="text-sm text-gray-600">左侧车道数量变化</label>
                        <select id="select-leftside-lanecountchange-selection" class="text-sm border rounded px-2 py-1">
                            <option value="none">没有变化</option>
                            <option value="reduce">车道减少</option>
                            <option value="increase">车道增加</option>
                        </select>
                    </div>

                    <div class="flex justify-between items-center">
                        <label class="text-sm text-gray-600">起点道路对齐</label>
                        <select id="select-startpoint-alignment" class="text-sm border rounded px-2 py-1">
                            <option value="center-align">中间对齐</option>
                            <option value="left-align">左侧对齐</option>
                            <option value="right-align">右侧对齐</option>
                        </select>
                    </div>
                    <div class="flex justify-between items-center">
                        <label class="text-sm text-gray-600">终点道路对齐</label>
                        <select id="select-endpoint-alignment" class="text-sm border rounded px-2 py-1">
                            <option value="center-align">中间对齐</option>
                            <option value="left-align">左侧对齐</option>
                            <option value="right-align">右侧对齐</option>
                        </select>
                    </div>
                    
                    <!-- 车道线信息（可折叠） -->
                    <div class="mt-4">
                        <div id="lane-markers-header" class="flex justify-between items-center cursor-pointer p-2 bg-gray-50 rounded-lg border border-gray-200 hover:bg-gray-100">
                            <h4 class="text-sm font-medium text-gray-600">车道线设置</h4>
                            <i class="fa fa-chevron-down transition-transform duration-300" id="lane-markers-toggle"></i>
                        </div>
                        <div id="lane-markers-container" class="space-y-3 mt-2 hidden p-3 bg-gray-50 rounded-lg border border-gray-200 border-t-0">
                            <!-- 车道线设置将通过JavaScript动态生成 -->
                        </div>
                    </div>
                    
                    <!-- 车道参数设置（可折叠） -->
                    <div class="mt-4">
                        <div id="lane-params-header" class="flex justify-between items-center cursor-pointer p-2 bg-gray-50 rounded-lg border border-gray-200 hover:bg-gray-100">
                            <h4 class="text-sm font-medium text-gray-600">车道参数设置</h4>
                            <i class="fa fa-chevron-down transition-transform duration-300" id="lane-params-toggle"></i>
                        </div>
                        <div id="lane-params-container" class="space-y-3 mt-2 hidden p-3 bg-gray-50 rounded-lg border border-gray-200 border-t-0">
                            <!-- 车道参数设置将通过JavaScript动态生成 -->
                        </div>
                    </div>
                </div>

            `;
            leftLaneContainer = document.querySelector('.left-lane-container');
            selectedRoadLeftLanesInput = document.getElementById('selected-road-left-lanes-input');
            selectedRoadRightLanesInput = document.getElementById('selected-road-right-lanes-input');
            selectedRoadWidthInput = document.getElementById('selected-road-width-input');
            selectedRoadDirectionSelect = document.getElementById('selected-road-direction-select');
            selectedRoadAlignmentStart = document.getElementById('select-startpoint-alignment');
            selectedRoadAlignmentEnd = document.getElementById('select-endpoint-alignment');
             // 添加车道减少选择器引用
            selectedRoadLeftLaneCountChangeSelect = document.getElementById('select-leftside-lanecountchange-selection');
            selectedRoadRightLaneCountChangeSelect = document.getElementById('select-rightside-lanecountchange-selection');
            selectedRoadStartHeightInput = document.getElementById('selected-road-start-height-input');
            selectedRoadEndHeightInput = document.getElementById('selected-road-end-height-input'); 
            // 添加折叠功能事件监听
            document.getElementById('lane-markers-header').addEventListener('click', function() {
                const container = document.getElementById('lane-markers-container');
                const toggleIcon = document.getElementById('lane-markers-toggle');
                container.classList.toggle('hidden');
                toggleIcon.classList.toggle('transform');
                toggleIcon.classList.toggle('rotate-180');
            });
            
            document.getElementById('lane-params-header').addEventListener('click', function() {
                const container = document.getElementById('lane-params-container');
                const toggleIcon = document.getElementById('lane-params-toggle');
                container.classList.toggle('hidden');
                toggleIcon.classList.toggle('transform');
                toggleIcon.classList.toggle('rotate-180');
            });
            
            // 重新绑定方向选择事件
            document.getElementById('selected-road-direction-select').addEventListener('change', function() {
                
                if (this.value === 'two-way') {
                    leftLaneContainer.classList.remove('hidden');
                } else {
                    leftLaneContainer.classList.add('hidden');
                }
            });

            
        }

        // 修改：重新绘制道路
        function redrawRoad(roadIndex) {
            const road = roads[roadIndex];
            const roadElement = document.querySelector(`.road-element-group[data-road-id="${road.id}"]`);
            const roadShape = document.querySelector(`.road-shape-group[data-road-id="${road.id}"]`);
            const roadIdText = document.querySelector(`#road-id-text-${road.id}`);
            const backgroundRect = document.querySelector(`#road-id-text-background-${road.id}`);

            console.log("redrawing road",road.id)
            if (roadElement && roadElement.parentNode && roadShape && roadShape.parentNode && roadIdText && backgroundRect) {
                // 移除旧道路
                roadElement.parentNode.removeChild(roadElement);
                roadShape.parentNode.removeChild(roadShape);
                roadIdText.parentNode.removeChild(roadIdText);
                backgroundRect.parentNode.removeChild(backgroundRect);

                // 绘制新道路
                drawsingleroad(road.start, road.end, road.id);
            }
        }


        function pointInPolygon(point, polygon) {
            let inside = false;

            const x = point.x, y = point.y;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            
            return inside;
        }


        function convertStringToFloatArray(str) {
            // 使用逗号分割字符串
            const parts = str.split(',');
            
            // 检查是否正好分割出两个部分
            if (parts.length !== 2) {
                throw new Error('输入字符串格式不正确，需要包含且仅包含一个逗号');
            }
            
            // 转换为浮点数并放入数组
            const result = [
                parseFloat(parts[0]),
                parseFloat(parts[1])
            ];
            
            // 检查转换是否成功
            if (result.some(isNaN)) {
                throw new Error('无法将部分内容转换为浮点数');
            }
            
            return result;
        }


        function lineIntersection(a1, a2, b1, b2) {

            const denom = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

            if (denom === 0) return null; // 平行线段
            
            const ua = ((b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x)) / denom;
            const ub = ((a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x)) / denom;

            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                
                return {
                    x: a1.x + ua * (a2.x - a1.x),
                    y: a1.y + ua * (a2.y - a1.y)
                };
            }
            
            return null;
        }


        function isPointInsideEdge(point, edgeStart, edgeEnd) {
            return (edgeEnd.x - edgeStart.x) * (point.y - edgeStart.y) - 
                (edgeEnd.y - edgeStart.y) * (point.x - edgeStart.x) < 0;
        }

        // 修改后：
        function isPointOutsideEdge(point, edgeStart, edgeEnd) {
            return (edgeEnd.x - edgeStart.x) * (point.y - edgeStart.y) - (edgeEnd.y - edgeStart.y) * (point.x - edgeStart.x) <= 0;
        }


        function drawsingleroad(start, end, roadId){

            drawRoadShape(start, end, roadId);
            drawRoadelement(start, end, roadId);
            console.log("Road number",road.id," Element Drawing Done")
        }

        // 绘制道路
        function drawRoadShape(start, end, roadId) {
            //Every time we draw a road, the road geometrie needs to be draw accordingly
            const roadGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            roadGroup.classList.add('road-shape-group');
            roadGroup.dataset.roadId = roadId;
            // 路肩宽度为5，车道宽度为3.75
            let shoulderWidth = 5;
            let laneWidth = 3.75;
            let polygonPoints = []; // 构建多边形点数组
            let rightreduce = "none";
            let leftreduce = "none";
            let startConnectedToIntersection;
            let endConnectedToIntersection;
            // 获取道路数据
            const road = roads.find(r => r.id === roadId);
            const roadpatch = road.roadpatch;
            let roadgeoform = determineroadgeometrie(road) //根据道路输入参数和关联关系计算道路中心线的曲线（位置，形状，点集）该数据不收intersection影响
            start = roadgeoform.startPoint; // 获取定义道路起点
            end = roadgeoform.endPoint; // 获取道路终点
            road.controlPoint1 = roadgeoform.controlPoints.control1; // 获取道路贝塞尔曲线控制点
            road.controlPoint2 = roadgeoform.controlPoints.control2; // 获取道路贝塞尔曲线控制点

            const leftlanecountchange = road ? road.leftlaneCountChange || 'none' : 'none';   // 获取道路左侧车道数量变化情况
            const rightlanecountchange = road ? road.rightlaneCountChange || 'none' : 'none'; // 获取道路右侧车道数量变化情况
            let currentRoadWidth = road ? road.width : roadWidth;
            const currentRoadDirection = road ? road.direction : roadDirection;
            const leftLanes = road ? (road.leftLanes || 0) : (currentRoadDirection === 'two-way' ? roadLeftLanes : 0);
            const rightLanes = road ? (road.rightLanes || 1) : roadRightLanes;
            const leftwidth = leftLanes*3.75 +5;
            const rightwidth = rightLanes*3.75+5;            
            let lanemarkersnumber = leftLanes+rightLanes+1;
            const controlPoints = road && road.controlPoint1 && road.controlPoint2 ? 
                                { control1: road.controlPoint1, control2: road.controlPoint2 } : 
                                calculateControlPoint(start, end, curvature);

            const centerLinePoints = calculateCubicBezierPoints(start, controlPoints.control1, controlPoints.control2, end, 2);
            road.roadcenterline = centerLinePoints;
            // 创建道路路径（曲线）
            const roadPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // 计算道路的边缘点
            const halfWidth = currentRoadWidth / 2;
            const leftEdgePoints = [];
            const rightEdgePoints = [];


            // 开始生成道路的内容以及绘制
            if (road) {
                let markers = road.lanemarkers
                // 清空现有路沿和车道线数据,将重新生成
                road.roadedge = [];
                // road.lanemarkers = [];
                road.roadedgeuncut = [];
                let leftCurbOffset = 0; //初始化路边缘的偏移量
                let rightCurbOffset = 0; //初始化路边缘的偏移量

                //计算路沿标准偏移量，画布坐标系为向右为x正，向下为y正，且道路本身方想不重要，左侧为负，右侧为正，
                leftCurbOffset = -halfWidth +0.5; // 向左偏移，距离道路边缘1像素
                rightCurbOffset = +halfWidth - 0.5; // 向右偏移

                // 调整路沿偏移，考虑车道减少，
                let adjustedLeftOffset = 0;
                let adjustedRightOffset = 0;
                
                // 对于双向道路，左右路沿的偏移计算方式不同
                if (currentRoadDirection === 'two-way') {
                    // 双向道路：左侧减少时，左侧路沿应向外偏移
                    if (rightlanecountchange === 'reduce') {// 右侧车道减少，该情况为起点处最外侧车道宽度较小，则减去一个根车道宽度
                        adjustedRightOffset = -laneWidth; 
                        rightreduce = "end"
                    }
                    else if(rightlanecountchange === 'increase'){
                        adjustedRightOffset = -laneWidth; // 向外偏移（增加左侧空间）
                        rightreduce = "start"
                    }
                    if (leftlanecountchange === 'reduce') {
                        adjustedLeftOffset = laneWidth; // 向外偏移（增加右侧空间）
                        leftreduce = "start"
                    }
                    else if (leftlanecountchange === 'increase') {
                        adjustedLeftOffset = laneWidth; // 向外偏移（增加右侧空间）
                        leftreduce = "end"
                    }
                } 
                else {// 单向道路
                    if (rightlanecountchange === 'reduce') {// 右侧车道减少，该情况为起点处最外侧车道宽度较小，则减去一个根车道宽度
                        adjustedRightOffset = -laneWidth; 
                        rightreduce = "end"
                    }
                    else if(rightlanecountchange === 'increase'){
                        adjustedRightOffset = -laneWidth;  // 
                        rightreduce = "start"
                    }
                    if (leftlanecountchange === 'reduce') {
                        adjustedLeftOffset = laneWidth; // 向外偏移（增加右侧空间）
                        leftreduce = "end"
                    }
                    else if (leftlanecountchange === 'increase') {
                        adjustedLeftOffset = laneWidth; // 向外偏移（增加右侧空间）
                        leftreduce = "start"
                    }
                }
                
                //根据道路情况独立生成路沿数据和绘制和道路elimnation情况进行数据生成
                // 生成路沿数据
                const heightvector = [Math.max(road.leftcurbelim[0],road.rightcurbelim[0]),Math.min(road.leftcurbelim[1],road.rightcurbelim[1])]
                const leftCurbData = generateLaneMarkerData(centerLinePoints, road, roadgeoform,'#000111', 'left_curb', leftCurbOffset,adjustedLeftOffset, 0, 0, 0, "Left_Curb",road.leftcurbelim,leftreduce,"normal",heightvector);
                const rightCurbData = generateLaneMarkerData(centerLinePoints, road, roadgeoform,'#000111', 'right_curb', rightCurbOffset,adjustedRightOffset, 0,0, 0, "Right_Curb",road.rightcurbelim,rightreduce,"normal",heightvector);

                
                const leftCurbDatauncut = generateLaneMarkerData(centerLinePoints, road, roadgeoform,'#000111', 'left_curb', leftCurbOffset,adjustedLeftOffset, 0, 0, 0, "Left_Curb",[0,8001],leftreduce,"normal",heightvector);
                const rightCurbDatauncut = generateLaneMarkerData(centerLinePoints, road, roadgeoform,'#000111', 'right_curb', rightCurbOffset,adjustedRightOffset, 0,0, 0, "Right_Curb",[0,8001],rightreduce,"normal",heightvector);

                

                const leftBoundDatawithheight = generateLaneMarkerData(centerLinePoints, road, roadgeoform,'#000111', 'left_curb', leftCurbOffset,adjustedLeftOffset, 0, 0, 0, "Left_Curb",heightvector,leftreduce,"nocut",heightvector);
                const rightBoundDatawithheight = generateLaneMarkerData(centerLinePoints, road, roadgeoform,'#000111', 'right_curb', rightCurbOffset,adjustedRightOffset, 0,0, 0, "Right_Curb",heightvector,rightreduce,"nocut",heightvector); 

                
                
                const leftedgeforshape = road.shapecutting == 0? leftCurbDatauncut : leftCurbData;
                const rightedgeforshape = road.shapecutting == 0? rightCurbDatauncut : rightCurbData;
                                // 示例使用
                const startPoint = rightedgeforshape.samplingPoints[rightedgeforshape.samplingPoints.length-1]; // 起点
                const endPoint = leftedgeforshape.samplingPoints[leftedgeforshape.samplingPoints.length - 1];  // 终点
                const linePoints1 = getLinePoints(startPoint, endPoint);

                const startPoint2 = leftedgeforshape.samplingPoints[0]; // 起点
                const endPoint2 = rightedgeforshape.samplingPoints[0];

                const linePoints2 = getLinePoints(startPoint2, endPoint2);

                const centerpoint = centerLinePoints[parseInt(centerLinePoints.length/2)];
                // console.log(rightedgeforshape.samplingPoints[rightedgeforshape.samplingPoints.length-1],leftedgeforshape.samplingPoints[leftedgeforshape.samplingPoints.length - 1])
                // polygonPoints.push(centerpoint);
                //生成道路多边形（根据路沿点）
                // 添加左边缘的所有点
                for (let i = 0; i < rightedgeforshape.samplingPoints.length; i++) {
                    const p = rightedgeforshape.samplingPoints[i];
                    polygonPoints.push({x: p.x, y: p.y});
                }

                for (let i = 0; i < linePoints1.length; i++) {
                    const p = linePoints1[i];
                    polygonPoints.push({x: p.x, y: p.y});
                }

                // 添加右边缘的所有点（反向）
                for (let i = leftedgeforshape.samplingPoints.length - 1; i >= 0; i--) {
                    const p = leftedgeforshape.samplingPoints[i];
                    polygonPoints.push({x: p.x, y: p.y});
                }
                for (let i = 0; i < linePoints2.length; i++) {
                    const p = linePoints2[i];
                    polygonPoints.push({x: p.x, y: p.y});
                }
 
                // 构建路径数据
                let roadPolygonshape = `M ${polygonPoints[0].x},${polygonPoints[0].y} `;
                for (let i = 1; i < polygonPoints.length; i++) {
                    roadPolygonshape += `L ${polygonPoints[i].x},${polygonPoints[i].y} `;
                }
                roadPolygonshape += 'Z';

                roadPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // 设置多边形点数据
                roadPolygon.setAttribute('d', roadPolygonshape);
                roadPolygon.setAttribute('fill', '#AAAAAA'); // 浅灰色道路
                roadPolygon.classList.add('road-polygon');
                
                // 添加到组
                roadGroup.appendChild(roadPolygon);
                road.roadshape = polygonPoints;
                road.leftboundshape = leftBoundDatawithheight.samplingPoints;
                road.rightboundshape = rightBoundDatawithheight.samplingPoints;
                
                if (road.roadpatch.length>0){
                    // patch = road.roadpatch;
                    road.roadpatch.forEach(patch=>{
                        let roadpatchshape = `M${patch[0].x},${patch[0].y} `;
                        for (let i = 1; i < patch.length; i++) {
                            roadpatchshape += `L ${patch[i].x},${patch[i].y} `;
                        }
                        roadpatchshape += 'Z';
                        roadpatchPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        roadpatchPolygon.setAttribute('d', roadpatchshape);
                        roadpatchPolygon.setAttribute('fill', '#AAAAAA'); // 浅灰色道路
                        roadpatchPolygon.classList.add('road-patch');
                        roadGroup.appendChild(roadpatchPolygon);
                        road.roadpatchshape = roadpatchshape;
                    })
                }   

                // drawLaneMarker(roadGroup, leftCurbData.samplingPoints, leftCurbData.color, 'left_curb');
                // drawLaneMarker(roadGroup, rightCurbData.samplingPoints, rightCurbData.color, 'right_curb');
                
                if(road.connectionFrom.length>0){
                     startConnectedToIntersection = road.connectionFrom[0].from_type;
                }else{
                     startConnectedToIntersection = "";
                }
                if(road.connectionTo.length>0){
                     endConnectedToIntersection = road.connectionTo[0].to_type;
                }else{
                     endConnectedToIntersection = "";
                }
                const gappointstart = startConnectedToIntersection=="intersection"?2:0;
                const gappointend = endConnectedToIntersection=="intersection"?2:0;
                
                // 添加路沿数据
                road.roadedge.push(leftCurbData,rightCurbData);
                road.roadedgeuncut.push(leftCurbDatauncut,rightCurbDatauncut)

            };

            // 添加到SVG
            roadSvg.appendChild(roadGroup);
            // console.log("Road number",road.id," Shape Drawing Done")            
        }

        // 添加一个新函数，用于同时导出地图数据和图片，并使用统一的文件名
        function exportMapResults() {
            // 准备默认文件名
            const defaultFileName = `MapExport_${new Date().toISOString().replace(/[:.]/g, '-')}`;
            
            // 提示用户输入文件名
            const fileName = promptForFileName(defaultFileName, '导出地图');
            
            // 如果用户取消，则不执行导出操作
            if (fileName === null) {
                return;
            }
            
            // 调用generatemapfile并传递自定义文件名
            generatemapfile(`${fileName}_data.json`);
            
            // 延迟调用saveCanvas，确保上一个下载完成
            setTimeout(() => {
                saveCanvas(`${fileName}_image`);
            }, 500);

                        // 延迟调用saveCanvas，确保上一个下载完成
            setTimeout(() => {
                saveMapScene(`${fileName}_project`);
            }, 500);

            // offerManualRunOption();
        }

        // 提供手动运行选项的函数
        function offerManualRunOption() {
            // 创建一个提示，让用户知道可以手动运行Python文件
            if (confirm('无法自动运行Python脚本。\n\n您可以手动运行文件夹中的AutoScene3D.py文件。\n\n是否打开文件夹？')) {
                // 尝试打开文件所在文件夹
                // 注意：这种方式在不同浏览器中的支持程度不同
                window.open('.', '_blank');
            }
        }

        function getLinePoints(start, end) {
            const points = [];
            const n = 20; // 取20个点
            const step = 1 / (n - 1); // 步长（0到1之间分19份）

            // 计算x和y方向的总增量
            const dx = end.x - start.x;
            const dy = end.y - start.y;

            // 生成20个点
            for (let i = 0; i < n; i++) {
                const t = i * step; // 当前参数t（0, 1/19, 2/19, ..., 1）
                const x = start.x + t * dx;
                const y = start.y + t * dy;
                points.push({ x: parseFloat(x.toFixed(6)), y: parseFloat(y.toFixed(6)) }); // 保留6位小数避免精度问题
            }

            return points;
        }
        
        // 绘制道路
        function drawRoadelement(start, end, roadId) {
            //Every time we draw a road, the road geometrie needs to be draw accordingly
            // 获取已创建的道路组
            const roadGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            roadGroup.classList.add('road-element-group');
            roadGroup.dataset.roadId = roadId;
            if (!roadGroup) return;
            // 路肩宽度为5，车道宽度为3.75
            let shoulderWidth = 5;
            let laneWidth = 3.75;
            let polygonPoints = []; // 构建多边形点数组
            let rightreduce = "none";
            let leftreduce = "none";
            let startConnectedToIntersection;
            let endConnectedToIntersection;
            // 获取道路数据
            const road = roads.find(r => r.id === roadId);
            const roadpatch = road.roadpatch;
            let roadgeoform = determineroadgeometrie(road) //根据道路输入参数和关联关系计算道路中心线的曲线（位置，形状，点集）该数据不收intersection影响
            start = roadgeoform.startPoint; // 获取定义道路起点
            end = roadgeoform.endPoint; // 获取道路终点
            road.controlPoint1 = roadgeoform.controlPoints.control1; // 获取道路贝塞尔曲线控制点
            road.controlPoint2 = roadgeoform.controlPoints.control2; // 获取道路贝塞尔曲线控制点

            const leftlanecountchange = road ? road.leftlaneCountChange || 'none' : 'none';   // 获取道路左侧车道数量变化情况
            const rightlanecountchange = road ? road.rightlaneCountChange || 'none' : 'none'; // 获取道路右侧车道数量变化情况
            let currentRoadWidth = road ? road.width : roadWidth;
            const currentRoadDirection = road ? road.direction : roadDirection;
            const leftLanes = road ? (road.leftLanes || 0) : (currentRoadDirection === 'two-way' ? roadLeftLanes : 0);
            const rightLanes = road ? (road.rightLanes || 1) : roadRightLanes;
            const leftwidth = leftLanes*3.75 +5;
            const rightwidth = rightLanes*3.75+5;            
            let lanemarkersnumber = leftLanes+rightLanes+1;
            const controlPoints = road && road.controlPoint1 && road.controlPoint2 ? 
                                { control1: road.controlPoint1, control2: road.controlPoint2 } : 
                                calculateControlPoint(start, end, curvature);

            const centerLinePoints = calculateCubicBezierPoints(start, controlPoints.control1, controlPoints.control2, end, 2);
            road.roadcenterline = centerLinePoints;
            // 创建道路路径（曲线）
            const roadPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // 计算道路的边缘点
            const halfWidth = currentRoadWidth / 2;
            const leftEdgePoints = [];
            const rightEdgePoints = [];


            // 开始生成道路的内容以及绘制
            if (road) {
                let markers = road.lanemarkers
                // 清空现有路沿和车道线数据,将重新生成
                // road.roadedge = [];
                road.lanemarkers = [];
                // road.roadedgeuncut = [];
                let leftCurbOffset = 0; //初始化路边缘的偏移量
                let rightCurbOffset = 0; //初始化路边缘的偏移量

                //计算路沿标准偏移量，画布坐标系为向右为x正，向下为y正，且道路本身方想不重要，左侧为负，右侧为正，
                leftCurbOffset = -halfWidth +0.5; // 向左偏移，距离道路边缘1像素
                rightCurbOffset = +halfWidth - 0.5; // 向右偏移

                // 调整路沿偏移，考虑车道减少，
                let adjustedLeftOffset = 0;
                let adjustedRightOffset = 0;
                
                // 对于双向道路，左右路沿的偏移计算方式不同
                if (currentRoadDirection === 'two-way') {
                    // 双向道路：左侧减少时，左侧路沿应向外偏移
                    if (rightlanecountchange === 'reduce') {// 右侧车道减少，该情况为起点处最外侧车道宽度较小，则减去一个根车道宽度
                        adjustedRightOffset = -laneWidth; 
                        rightreduce = "end"
                    }
                    else if(rightlanecountchange === 'increase'){
                        adjustedRightOffset = -laneWidth; // 向外偏移（增加左侧空间）
                        rightreduce = "start"
                    }
                    if (leftlanecountchange === 'reduce') {
                        adjustedLeftOffset = laneWidth; // 向外偏移（增加右侧空间）
                        leftreduce = "start"
                    }
                    else if (leftlanecountchange === 'increase') {
                        adjustedLeftOffset = laneWidth; // 向外偏移（增加右侧空间）
                        leftreduce = "end"
                    }
                } 
                else {// 单向道路
                    if (rightlanecountchange === 'reduce') {// 右侧车道减少，该情况为起点处最外侧车道宽度较小，则减去一个根车道宽度
                        adjustedRightOffset = -laneWidth; 
                        rightreduce = "end"
                    }
                    else if(rightlanecountchange === 'increase'){
                        adjustedRightOffset = -laneWidth;  // 
                        rightreduce = "start"
                    }
                    if (leftlanecountchange === 'reduce') {
                        adjustedLeftOffset = laneWidth; // 向外偏移（增加右侧空间）
                        leftreduce = "end"
                    }
                    else if (leftlanecountchange === 'increase') {
                        adjustedLeftOffset = laneWidth; // 向外偏移（增加右侧空间）
                        leftreduce = "start"
                    }
                }
                
                //根据道路情况独立生成路沿数据和绘制和道路elimnation情况进行数据生成
                // 生成路沿数据

                let heightvector = [Math.max(road.leftcurbelim[0],road.rightcurbelim[0]),Math.min(road.leftcurbelim[1],road.rightcurbelim[1])]

                const leftCurbData = generateLaneMarkerData(centerLinePoints, road, roadgeoform,'#000111', 'left_curb', leftCurbOffset,adjustedLeftOffset, 0, 0, 0, "Left_Curb",road.leftcurbelim,leftreduce,"normal",[0,8001]);
                const rightCurbData = generateLaneMarkerData(centerLinePoints, road, roadgeoform,'#000111', 'right_curb', rightCurbOffset,adjustedRightOffset, 0,0, 0, "Right_Curb",road.rightcurbelim,rightreduce,"normal",[0,8001]);

                
                const leftCurbDatauncut = generateLaneMarkerData(centerLinePoints, road, roadgeoform,'#000111', 'left_curb', leftCurbOffset,adjustedLeftOffset, 0, 0, 0, "Left_Curb",[0,8001],leftreduce,"normal",[0,8001]);
                const rightCurbDatauncut = generateLaneMarkerData(centerLinePoints, road, roadgeoform,'#000111', 'right_curb', rightCurbOffset,adjustedRightOffset, 0,0, 0, "Right_Curb",[0,8001],rightreduce,"normal",[0,8001]);
                
                const leftedgeforshape = road.shapecutting == 0? leftCurbDatauncut : leftCurbData;
                const rightedgeforshape = road.shapecutting == 0? rightCurbDatauncut : rightCurbData;


                drawLaneMarker(roadGroup, leftCurbData.samplingPoints, leftCurbData.color, 'left_curb');
                drawLaneMarker(roadGroup, rightCurbData.samplingPoints, rightCurbData.color, 'right_curb');
                
                if(road.connectionFrom.length>0){
                     startConnectedToIntersection = road.connectionFrom[0].from_type;
                }else{
                     startConnectedToIntersection = "";
                }
                if(road.connectionTo.length>0){
                     endConnectedToIntersection = road.connectionTo[0].to_type;
                }else{
                     endConnectedToIntersection = "";
                }
                const gappointstart = startConnectedToIntersection=="intersection"?2:0;
                const gappointend = endConnectedToIntersection=="intersection"?2:0;
                
                // 添加路沿数据
                // road.roadedge.push(leftCurbData,rightCurbData);
                // road.roadedgeuncut.push(leftCurbDatauncut,rightCurbDatauncut)
                // 计算车道线位置和绘制车道线
                if (currentRoadDirection === 'two-way') {
                    const order = leftLanes+1;
                    const seperatoroffset = (leftLanes-rightLanes)==0?0:(leftLanes-rightLanes)/2*laneWidth;
                    const marker = markers.find(item => item.index === order);
                    const color = layoutchange ? "#FFFF00" : (marker ? marker.color : "#FFFF00");
                    const type = layoutchange ? "solid_double":(marker?marker.type:"solid_double");
                    const name = layoutchange ? "DividerLine":(marker?marker.name:"DividerLine");
                    // 生成中央黄线数据
                    const separatorData = generateLaneMarkerData(centerLinePoints,road,roadgeoform,color,type,seperatoroffset,seperatoroffset,order,gappointstart,gappointend,name,[0,8001],"none","normal",heightvector);    
                    road.lanemarkers.push(separatorData);
                    // 双向道路：绘制中央黄线

                    drawLaneMarker(roadGroup,separatorData.samplingPoints,separatorData.color,separatorData.type);

                    // 绘制左侧车道线
                    for (let i = 1; i < leftLanes+1; i++) {
                        const offset = -(i * laneWidth)+seperatoroffset;
                        const order = i;
                        const marker = markers.find(item => item.index === order);
                        const color = layoutchange ? "#FFFFFF" : (marker ? marker.color : "#FFFFFF");
                        const type = layoutchange ? (i===leftLanes?"solid_single":"dashed_single"):(marker?marker.type:"solid_single");
                        const name = layoutchange ? "Left_Line_"+i:(marker?marker.name:"Left_Line_"+i);
                        
                        // 对于最外侧车道线，考虑车道减少
                        let leftlinereduceoffset = 0;
                        if (i === leftLanes) {
                            leftlinereduceoffset = adjustedLeftOffset;
                        }

                        const leftLaneData = generateLaneMarkerData(centerLinePoints,road,roadgeoform,color,type,offset,leftlinereduceoffset,order,gappointstart,gappointend,name,[0,8001],leftreduce,"normal",heightvector);
                        road.lanemarkers.push(leftLaneData);
                        drawLaneMarker(roadGroup,leftLaneData.samplingPoints,leftLaneData.color,leftLaneData.type);
                    }
                
                    // 绘制右侧车道线

                    for (let i = 1; i < rightLanes+1; i++) {
                        const offset = (i * laneWidth)+seperatoroffset;
                        const order = leftLanes+1+i;
                        const marker = markers.find(item => item.index === order);
                        const color = layoutchange ? "#FFFFFF" : (marker ? marker.color : "#FFFFFF");
                        const type = layoutchange ? (i===rightLanes?"solid_single":"dashed_single"):(marker?marker.type:"solid_single");
                        const name = layoutchange ? "Right_Line_"+i:(marker?marker.name:"Right_Line_"+i);
                        let rightlinereduceoffset = 0;
                        if (i === rightLanes) {
                            rightlinereduceoffset = adjustedRightOffset;
                        }
                        
                        const rightLaneData = generateLaneMarkerData(centerLinePoints,road,roadgeoform,color,type,offset,rightlinereduceoffset,order,gappointstart,gappointend,name,[0,8001],rightreduce,"normal",heightvector);
                        road.lanemarkers.push(rightLaneData);
                        drawLaneMarker(roadGroup,rightLaneData.samplingPoints,rightLaneData.color,rightLaneData.type);
                    }
                }else{
                    for (let i = 0; i <= rightLanes; i++) {
                        const offset = (i* laneWidth)-halfWidth+shoulderWidth ;
                        const order = i;
                        const marker = markers.find(item => item.index === order);
                        const color = layoutchange ? "#FFFFFF" : (marker ? marker.color : "#FFFFFF");
                        const type = layoutchange ? "solid_single":(marker?marker.type:"solid_single");
                        const name = layoutchange ? "Line_"+i:(marker?marker.name:"Line_"+i);
                        let rightlinereduceoffset = 0;
                        if (i === rightLanes) {
                            rightlinereduceoffset = adjustedRightOffset;
                        }else if(i === 0){
                            rightlinereduceoffset = adjustedLeftOffset;
                        }
                        const rightLaneData = generateLaneMarkerData(centerLinePoints,road,roadgeoform,color,type,offset,rightlinereduceoffset,order,gappointstart,gappointend,name,[0,8001],rightreduce,"normal",heightvector);    
                        road.lanemarkers.push(rightLaneData);
                        drawLaneMarker(roadGroup,rightLaneData.samplingPoints,rightLaneData.color,rightLaneData.type);
                    }
                }
            }
                        // 找出黄色分割线的索引（用于双向道路）
            let yellowLineIndex = -1;
            if (road.direction === 'two-way') {
                yellowLine = road.lanemarkers.find(marker => marker.color === '#FFFF00');
                yellowLineIndex = yellowLine.index
            }
            
            // 清空现有的停止线数据
            road.stopLines = [];
            road.trafficlights = [];
            road.zebraCrossings = [];

            
            // 为行驶方向上终结的道路添加停止线
            if (road.direction === 'one-way' || road.direction === 'two-way') {
                const shifting = (rightwidth-leftwidth)/2
                // 右侧行驶方向（与道路绘制方向一致）
                if (endConnectedToIntersection == "intersection") {
                    drawStopLinesForDirection(road, roadGroup, centerLinePoints, 'right', yellowLineIndex,2,shifting);
                }
                
                // 如果是双向道路，处理左侧行驶方向（与道路绘制方向相反）
                if (road.direction === 'two-way' && startConnectedToIntersection =="intersection") {
                    drawStopLinesForDirection(road, roadGroup, centerLinePoints, 'left', yellowLineIndex,2,shifting);
                }
            }

            // 绘制路灯
            drawStreetLights(road, roadGroup);
            // 添加道路ID文本
            if (road && centerLinePoints && centerLinePoints.length > 0) {
                // 计算道路中点
                const centerPoint = centerLinePoints[Math.floor(centerLinePoints.length / 2)];
                
                // 创建文本元素
                const roadIdText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                roadIdText.setAttribute('id', 'road-id-text-'+road.id);
                roadIdText.setAttribute('x', centerPoint.x);
                roadIdText.setAttribute('y', centerPoint.y);
                roadIdText.setAttribute('text-anchor', 'middle');
                roadIdText.setAttribute('dominant-baseline', 'middle');
                roadIdText.setAttribute('font-size', '14');
                roadIdText.setAttribute('fill', '#000000');
                roadIdText.setAttribute('font-weight', 'bold');
                roadIdText.setAttribute('font-family', 'Arial, sans-serif');
                
                // 添加半透明背景以提高可读性
                const backgroundRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const textLength = roadId.toString().length * 8; // 估算文本长度
                backgroundRect.setAttribute('id', 'road-id-text-background-'+road.id);
                backgroundRect.setAttribute('x', centerPoint.x - textLength / 2 - 5);
                backgroundRect.setAttribute('y', centerPoint.y - 10);
                backgroundRect.setAttribute('width', textLength + 10);
                backgroundRect.setAttribute('height', 20);
                backgroundRect.setAttribute('rx', 5);
                backgroundRect.setAttribute('fill', 'rgba(255, 255, 255, 0.8)');
                
                // 添加到道路组
                roadnumberSvg.appendChild(backgroundRect);
                roadnumberSvg.appendChild(roadIdText);
                
                // 设置文本内容
                roadIdText.textContent = roadId.toString();
            }
            
            // 调用生成车道函数
            let heightvector2 = [Math.max(road.leftcurbelim[0],road.rightcurbelim[0]),Math.min(road.leftcurbelim[1],road.rightcurbelim[1])]
            generateRoadLanes(centerLinePoints,road,roadgeoform,currentRoadWidth,shoulderWidth,heightvector2);
            road.arrows=[];
                // 确保道路箭头被正确绘制
            road.lanes.forEach((lane, index) => {
                if (lane.lanecenter && lane.lanecenter.samplingPoints.length > 0) {
                    drawLaneArrow(roadGroup, lane.lanecenter.samplingPoints, index, lane.direction, lane.turnDirection,lane.id,road.id,road);
                }
            });

            // 添加到SVG
            roadSvg.appendChild(roadGroup);
            // console.log("Road number",road.id," Element Drawing Done")            
        }

        // 添加绘制调整后车道线的辅助函数
        function drawAdjustedLaneMarker(roadGroup, offsetPoints, color, type, gap, gapend) {
            // 单线路线
            const laneLinePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

            // 构建车道线的路径数据
            let laneLineData = `M ${offsetPoints[gap].x},${offsetPoints[gap].y} `;

            // 添加车道线的曲线点
            for (let i = gap+1; i < offsetPoints.length-gapend; i++) {
                const p = offsetPoints[i];
                laneLineData += `L ${p.x},${p.y} `;
            }

            laneLinePath.setAttribute('d', laneLineData);
            laneLinePath.setAttribute('stroke', color);
            if(type.includes('curb')){
                width = "1";
            }else{width = "0.3";}
            laneLinePath.setAttribute('stroke-width', width);
            laneLinePath.setAttribute('fill', 'none');
            
            // 设置虚线样式
            if (type === 'dashed_single') {
                laneLinePath.setAttribute('stroke-dasharray', '10, 5');
            }

            laneLinePath.classList.add('road-path');
            roadGroup.appendChild(laneLinePath);
            
            return offsetPoints;
        }
        
        // 新增：生成车道信息函数
        function generateRoadLanes(centerLinePoints,road,roadgeoform,currentRoadWidth,shoulderWidth,heightvector){
            turnDirections = road.lanes.map(lane => lane.turnDirection);
            road.lanes = [];
            
            // 如果没有车道线数据，直接返回
            if (!road.lanemarkers || road.lanemarkers.length === 0) {
                return;
            }

            // 按index从小到大排序车道线
            const sortedLaneMarkers = [...road.lanemarkers].sort((a, b) => a.index - b.index);

            // 车道宽度（固定为3.75）
            const laneWidth = 3.75;
            
            // 从index=1开始，每两条连续的车道线生成一条车道
            for (let i = 0; i < sortedLaneMarkers.length - 1; i++) {
                const leftMarker = sortedLaneMarkers[i];
                const rightMarker = sortedLaneMarkers[i + 1];
                const offset = (-currentRoadWidth/2)+5+i*3.75+3.75/2;
                // 生成车道ID
                const laneId = `lane_${road.id}_${i + 1}`;
                
                // 计算车道长度（使用左车道线的弧长）
                let laneLength = 0;
                if (leftMarker.arcLengths && leftMarker.arcLengths.length > 0) {
                    laneLength = leftMarker.arcLengths[leftMarker.arcLengths.length - 1];
                }
                
                // 确定车道方向：右侧为driving，左侧为inverse
                // 对于双向道路，需要特殊处理中间的分隔线
                let direction = 'driving'; // 默认右侧行驶
                // 双向道路的情况
                if (road.direction === 'two-way') {
                    const centerIndex = Math.ceil(sortedLaneMarkers.length / 2);
                    if (i < road.leftLanes) {
                        // 左侧车道
                        direction = 'inverse';
                    } else if (i >= centerIndex - 1) {
                        // 右侧车道
                        direction = 'driving';
                    }
                }
                const lanecenterpoints = generateLaneMarkerData(centerLinePoints,road,roadgeoform, "#BBBBBB" ,"lanecenter", offset,0,i,0,0,"lanecenterline",[0,8001],'none',"normal",heightvector);
            
                // 创建车道数据对象
                const laneData = {
                    id: laneId,
                    length: laneLength,
                    left_laneline_id: leftMarker.id,
                    right_laneline_id: rightMarker.id,
                    width: laneWidth,
                    direction: direction,
                    lanecenter:lanecenterpoints,
                    // 新增转向信息属性
                    turnDirection: turnDirections[i]? turnDirections[i]:'straight', // 默认直行
                    // 新增待转区属性
                    hasWaitingZone: false // 默认没有待转区
                };
                // 添加到道路的车道数组中
                road.lanes.push(laneData);

            }
        }

        // 绘制车道箭头函数
        function drawLaneArrow(roadGroup, centerLinePoints, laneIndex, laneDirection, turnDirection,laneid,roadid,road) {
            // 计算箭头位置（30%和60%位置）
            const arrowPositions = [0.2,0.5, 0.8];
            
            arrowPositions.forEach((position,index) => {
                // 找到车道中心线上对应位置的点和方向
                const { point, direction } = findPointAtPosition(centerLinePoints, position);
                // 根据车道方向调整箭头方向
                let arrowAngle = Math.atan2(direction.y, direction.x);
                if (laneDirection === 'inverse') {
                    arrowAngle += Math.PI; // 反向车道箭头旋转180度
                }
                
                // 创建箭头组元素
                const arrowGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                arrowGroup.setAttribute('transform', `translate(${point.x}, ${point.y}) rotate(${arrowAngle * 180 / Math.PI})`);
                arrowGroup.classList.add('lane-arrow');
                
                // 根据转向信息绘制不同类型的箭头
                drawArrowByType(arrowGroup, turnDirection);
                road.arrows.push({
                    id: `arrow_${roadid}_${laneIndex}_${position}`,
                    posx:point.x,
                    posy:point.y,
                    posz:point.z,
                    angle:arrowAngle * 180 / Math.PI,
                    type:turnDirection,
                    RoadID:roadid,
                    LaneID:laneid,
                });
                roadGroup.appendChild(arrowGroup);
            });
        }

        // 在车道中心线特定位置找到点和方向
        function findPointAtPosition(centerLinePoints, position) {
            // 计算总长度
            let totalLength = 0;
            const segmentLengths = [];
            
            for (let i = 0; i < centerLinePoints.length - 1; i++) {
                const dx = centerLinePoints[i + 1].x - centerLinePoints[i].x;
                const dy = centerLinePoints[i + 1].y - centerLinePoints[i].y;
                const length = Math.sqrt(dx * dx + dy * dy);
                segmentLengths.push(length);
                totalLength += length;
            }
            
            // 找到目标位置所在的线段
            const targetLength = totalLength * position;
            let accumulatedLength = 0;
            let segmentIndex = 0;
            
            for (; segmentIndex < segmentLengths.length; segmentIndex++) {
                if (accumulatedLength + segmentLengths[segmentIndex] >= targetLength) {
                    break;
                }
                accumulatedLength += segmentLengths[segmentIndex];
            }
            
            // 计算在线段上的位置比例
            const segmentRatio = (targetLength - accumulatedLength) / segmentLengths[segmentIndex];
            const startPoint = centerLinePoints[segmentIndex];
            const endPoint = centerLinePoints[segmentIndex + 1];
            
            // 计算目标点
            const idealpoint = {
                x: startPoint.x + (endPoint.x - startPoint.x) * segmentRatio,
                y: startPoint.y + (endPoint.y - startPoint.y) * segmentRatio
            };

            newpoint = findNearestPoint(idealpoint,centerLinePoints);
            // console.log(centerLinePoints[newpoint])
            const point = centerLinePoints[newpoint];
            // 计算方向向量
            const direction = {
                x: endPoint.x - startPoint.x,
                y: endPoint.y - startPoint.y,
                z: endPoint.z - startPoint.z
            };
            
            // 归一化方向向量
            const dirLength = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
            if (dirLength > 0) {
                direction.x /= dirLength;
                direction.y /= dirLength;
            }
            
            return { point, direction };
        }

        // 根据转向类型绘制不同的箭头
        function drawArrowByType(arrowGroup, turnDirection) {
            // 箭头基本样式
            const arrowSize = 1; // 箭头大小
            const arrowColor = '#FFFFFF'; // 箭头颜色
            
            // 根据转向类型绘制不同的箭头组合
            switch (turnDirection) {
                case 'straight':
                    drawSingleArrow(arrowGroup, 0, 0, arrowSize, arrowColor);
                    break;
                case 'left':
                    drawLeftArrow(arrowGroup, 0, 0, arrowSize, arrowColor);
                    break;
                case 'right':
                    drawRightArrow(arrowGroup, 0, 0, arrowSize, arrowColor);
                    break;
                case 'left_straight':
                    drawStraightLeftArrow(arrowGroup, 0, 0, arrowSize, arrowColor);
                    // drawLeftArrow(arrowGroup, 0, -arrowSize/2, arrowSize, arrowColor);
                    break;
                case 'right_straight':
                    drawStraightRightArrow(arrowGroup, 0, 0, arrowSize, arrowColor);    
                    break;
                case 'to-right':
                    drawToRightArrow(arrowGroup, 0, 0, arrowSize, arrowColor);
                    break;
                case 'to-left':
                    drawToLeftArrow(arrowGroup, 0, 0, arrowSize, arrowColor);
                    break;
            }
        }

        // 绘制直箭头
        function drawSingleArrow(arrowGroup, x, y, size, color) {
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // 直箭头路径数据
            const pathData = `M ${x},${y} L ${x},${y-0.075}L ${x+1.8},${y-0.075}L ${x+1.8},${y-0.225}L ${x+3},${y} L ${x+1.8},${y+0.225} L ${x+1.8},${y+0.075}L ${x},${y+0.075}L ${x},${y} Z`;
            
            arrowPath.setAttribute('d', pathData);
            arrowPath.setAttribute('fill', color);

            
            arrowGroup.appendChild(arrowPath);
        }

        // 绘制左箭头
        function drawLeftArrow(arrowGroup, x, y, size, color) {
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // 左箭头路径数据
            const pathData = `M ${x},${y} L ${x},${y-0.075}L ${x+1.45},${y-0.075}L ${x+1.9},${y-0.475} L ${x+1.45},${y-0.475} L ${x+2.2},${y-0.675} L ${x+3},${y-0.475}L ${x+2.5},${y-0.475}L ${x+1.95},${y+0.075}L ${x},${y+0.075} Z`;
            
            arrowPath.setAttribute('d', pathData);
            arrowPath.setAttribute('fill', color);
            // arrowPath.setAttribute('stroke', color);
            // arrowPath.setAttribute('stroke-width', '0.1');
            
            arrowGroup.appendChild(arrowPath);
        }

        // 绘制右箭头
        function drawRightArrow(arrowGroup, x, y, size, color) {
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // 右箭头路径数据
            const pathData = `M ${x},${y} L ${x},${y+0.075}L ${x+1.45},${y+0.075}L ${x+1.9},${y+0.475} L ${x+1.45},${y+0.475} L ${x+2.2},${y+0.675} L ${x+3},${y+0.475}L ${x+2.5},${y+0.475}L ${x+1.95},${y-0.075}L ${x},${y-0.075} Z`;
            
            arrowPath.setAttribute('d', pathData);
            arrowPath.setAttribute('fill', color);
            // arrowPath.setAttribute('stroke', color);
            // arrowPath.setAttribute('stroke-width', '0.5');
            
            arrowGroup.appendChild(arrowPath);
        }

        // 绘制直行加左转箭头
        function drawStraightLeftArrow(arrowGroup, x, y, size, color) {
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // 直加左头路径数据
            const pathData = `M ${x},${y} L ${x},${y-0.075}L ${x+0.2},${y-0.075}L ${x+0.65},${y-0.475}L ${x+0.2},${y-0.475}L ${x+0.95},${y-0.675}L ${x+1.75},${y-0.475}L ${x+1.25},${y-0.475}L ${x+0.8},${y-0.075}L ${x+1.8},${y-0.075}L ${x+1.8},${y-0.225}L ${x+3},${y} L ${x+1.8},${y+0.225} L ${x+1.8},${y+0.075}L ${x},${y+0.075}L ${x},${y} Z`;
            
            arrowPath.setAttribute('d', pathData);
            arrowPath.setAttribute('fill', color);
            
            arrowGroup.appendChild(arrowPath);
        }

                // 绘制直行加左转箭头
        function drawStraightRightArrow(arrowGroup, x, y, size, color) {
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // 直加左头路径数据
            const pathData = `M ${x},${y} L ${x},${y+0.075}L ${x+0.2},${y+0.075}L ${x+0.65},${y+0.475}L ${x+0.2},${y+0.475}L ${x+0.95},${y+0.675}L ${x+1.75},${y+0.475}L ${x+1.25},${y+0.475}L ${x+0.8},${y+0.075}L ${x+1.8},${y+0.075}L ${x+1.8},${y+0.225}L ${x+3},${y} L ${x+1.8},${y-0.225} L ${x+1.8},${y-0.075}L ${x},${y-0.075}L ${x},${y} Z`;
            
            arrowPath.setAttribute('d', pathData);
            arrowPath.setAttribute('fill', color);
            
            arrowGroup.appendChild(arrowPath);
        }

        // 向右箭头
        function drawToRightArrow(arrowGroup, x, y, size, color) {
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // 直箭头路径数据
            const pathData = `M ${x},${y} L ${x},${y-0.075}L ${x+1.8},${y+0.275}L ${x+1.85},${y+0.2}L ${x+3},${y+0.6} L ${x+1.75},${y+0.5} L ${x+1.8},${y+0.425}L ${x},${y+0.075}L ${x},${y} Z`;
 
            arrowPath.setAttribute('d', pathData);
            arrowPath.setAttribute('fill', color);
            
            arrowGroup.appendChild(arrowPath);
        }

                // 向右箭头
        function drawToLeftArrow(arrowGroup, x, y, size, color) {
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // 直箭头路径数据
            const pathData = `M ${x},${y} L ${x},${y+0.075}L ${x+1.8},${y-0.275}L ${x+1.85},${y-0.2}L ${x+3},${y-0.6} L ${x+1.75},${y-0.5} L ${x+1.8},${y-0.425}L ${x},${y-0.075}L ${x},${y} Z`;
 
            arrowPath.setAttribute('d', pathData);
            arrowPath.setAttribute('fill', color);
            
            arrowGroup.appendChild(arrowPath);
        }

        // 新增函数：生成车道参数设置控件
        function generateLaneParamsControls(road) {
            const laneParamsContainer = document.getElementById('lane-params-container');
            laneParamsContainer.innerHTML = '';
            
            if (!road || !road.lanes || road.lanes.length === 0) {
                laneParamsContainer.innerHTML = '<p class="text-sm text-gray-500">没有可用的车道数据</p>';
                return;
            }
            
            // 为每条车道生成参数控件
            road.lanes.forEach((lane, index) => {
                const laneParamDiv = document.createElement('div');
                laneParamDiv.className = 'space-y-2 p-2 border border-gray-200 rounded-lg';
                
                const directionText = lane.direction === 'driving' ? '右侧车道' : '左侧车道';

                laneParamDiv.innerHTML = `
                    <div class="flex justify-between items-center">
                        <h5 class="text-sm font-medium text-gray-600">${directionText} ${index + 1}</h5>
                    </div>
                    
                    <!-- 转向信息选择器 -->
                    <div class="flex justify-between items-center">
                        <label class="text-sm text-gray-600">转向信息</label>
                        <select class="lane-turn-direction text-sm border rounded px-2 py-1" data-index="${index}">
                            <option value="straight" ${lane.turnDirection === 'straight' ? 'selected' : ''}>直行</option>
                            <option value="left" ${lane.turnDirection === 'left' ? 'selected' : ''}>左转</option>
                            <option value="right" ${lane.turnDirection === 'right' ? 'selected' : ''}>右转</option>
                            <option value="left_straight" ${lane.turnDirection === 'left_straight' ? 'selected' : ''}>左转+直行</option>
                            <option value="right_straight" ${lane.turnDirection === 'right_straight' ? 'selected' : ''}>右转+直行</option>
                            <option value="to-left" ${lane.turnDirection === 'to-left' ? 'selected' : ''}>向左</option>
                            <option value="to-right" ${lane.turnDirection === 'to-right' ? 'selected' : ''}>向右</option>
                        </select>
                    </div>
                    
                    <!-- 待转区勾选框 -->
                    <div class="flex justify-between items-center">
                        <label class="text-sm text-gray-600">有待转区</label>
                        <input type="checkbox" class="lane-waiting-zone" data-lane-index="${index}" ${lane.hasWaitingZone ? 'checked' : ''}>
                    </div>
                `;
                
                laneParamsContainer.appendChild(laneParamDiv);
            });
            
            // 添加事件监听以保存参数变化
            document.querySelectorAll('.lane-turn-direction').forEach(select => {
                select.addEventListener('change', function() {
                    const laneIndex = parseInt(this.dataset.index);
                    road.lanes[laneIndex].turnDirection = this.value;
                });
            });
            
            document.querySelectorAll('.lane-waiting-zone').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const laneIndex = parseInt(this.dataset.laneIndex);
                    road.lanes[laneIndex].hasWaitingZone = this.checked;
                });
            });
        }

        // 修改initSvgSize函数，添加SVG的viewBox属性以支持更好的缩放
        function initSvgSize() {
            const rect = mapContainer.getBoundingClientRect();
            mapSvg.setAttribute('width', rect.width);
            mapSvg.setAttribute('height', rect.height);
            mapSvg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
            mapSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            
            // 重置缩放变换
            zoomFactor = 1;
            mapSvg.setAttribute('transform', 'scale(1)');
        }

        // 重置比例尺
        function resetScale() {
            zoomFactor = 1;
            mapSvg.setAttribute('transform', 'scale(1)');
        }

        // 选择路口类型
        function selectIntersectionType(type) {
            selectedIntersectionType = type;
            
            // 更新UI
            crossIntersectionButton.classList.remove('bg-primary', 'text-white', 'border-primary');
            crossIntersectionButton.classList.add('bg-white', 'text-gray-700', 'border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5');
            
            tJunctionIntersectionButton.classList.remove('bg-primary', 'text-white', 'border-primary');
            tJunctionIntersectionButton.classList.add('bg-white', 'text-gray-700', 'border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5');
            
            straightIntersectionButton.classList.remove('bg-primary', 'text-white', 'border-primary');
            straightIntersectionButton.classList.add('bg-white', 'text-gray-700', 'border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5');
            
            if (type === 'cross') {
                crossIntersectionButton.classList.add('bg-primary', 'text-white', 'border-primary');
                crossIntersectionButton.classList.remove('bg-white', 'text-gray-700', 'border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5');
            } else if (type === 't-junction') {
                tJunctionIntersectionButton.classList.add('bg-primary', 'text-white', 'border-primary');
                tJunctionIntersectionButton.classList.remove('bg-white', 'text-gray-700', 'border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5');
            } else if (type === 'straight') {
                straightIntersectionButton.classList.add('bg-primary', 'text-white', 'border-primary');
                straightIntersectionButton.classList.remove('bg-white', 'text-gray-700', 'border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5');
            }
        }

        // 新增：处理键盘事件，用于删除选中的元素
        function handleKeyDown(event) {
            // 只有在修改器模式且有选中的道路时才响应删除键
            if (mainMode === 'modifier' && selectedRoadId !== null && event.key === 'Delete') {
                deleteSelectedRoad();
            }
            // 只有在修改器模式且有选中的路口时才响应删除键
            if (mainMode === 'modifier' && selectedIntersectionId !== null && event.key === 'Delete') {
                deleteSelectedIntersection();
            }
            
        }
        
        function deleteSelectedIntersection(){
            // 查找选中的路口索引
            const intersectionIndex = intersections.findIndex(intersection => intersection.id === selectedIntersectionId);
            if (intersectionIndex !== -1) {
                // 移除路口元素
                const intersectionElement = document.querySelector(`.intersection[data-intersection-id="${selectedIntersectionId}"]`);
                if (intersectionElement && intersectionElement.parentNode) {
                    intersectionElement.parentNode.removeChild(intersectionElement);
                }
                intersections.splice(intersectionIndex, 1);

                                // 更新连接关系（移除与该道路相关的连接）
                connections = connections.filter(connection => 
                    connection.from !== selectedRoadId && connection.to !== selectedRoadId
                );

                deselectIntersection();

                updateEndpointHints();

                // 显示提示
                showNotification('路口已删除', 'success');
            }
        }
        
        // 新增：删除选中的道路
        function deleteSelectedRoad() {
            // 查找选中的道路索引
            const roadIndex = roads.findIndex(road => road.id === selectedRoadId);
            
            if (roadIndex !== -1) {
                // 移除道路元素
                const roadElement = document.querySelector(`.road-element-group[data-road-id="${selectedRoadId}"]`);
                const roadShape = document.querySelector(`.road-shape-group[data-road-id="${selectedRoadId}"]`);
                const roadIdText = document.querySelector(`#road-id-text-${selectedRoadId}`);
                const backgroundRect = document.querySelector(`#road-id-text-background-${selectedRoadId}`);
                if (roadIdText && roadIdText.parentNode) {
                    roadIdText.parentNode.removeChild(roadIdText);
                }
                if (backgroundRect && backgroundRect.parentNode) {
                    backgroundRect.parentNode.removeChild(backgroundRect);
                }
                if (roadElement && roadElement.parentNode) {
                    roadElement.parentNode.removeChild(roadElement);
                }
                if (roadShape && roadShape.parentNode) {
                    roadShape.parentNode.removeChild(roadShape);
                }
                // 从数据中移除道路
                roads.splice(roadIndex, 1);
                
                // 更新连接关系（移除与该道路相关的连接）
                connections = connections.filter(connection => 
                    connection.from !== selectedRoadId && connection.to !== selectedRoadId
                );
                
                // 取消选中状态
                deselectRoad();
                
                // 更新道路信息
                updateRoadInfo();
                
                // 更新端点提示
                updateEndpointHints();
                
                // 显示提示
                showNotification('道路已删除', 'success');
            }
        }
        
        // 新增：计算二阶贝塞尔曲线上的点
        function calculateQuadraticBezierPoints(start, control, end, samplingInterval = 4) {
            const points = [];
            
            // 计算曲线总长度用于确定采样点数
            const segments = 100;
            let totalLength = 0;
            const segmentPoints = [];
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const x = Math.pow(1 - t, 2) * start.x + 2 * (1 - t) * t * control.x + Math.pow(t, 2) * end.x;
                const y = Math.pow(1 - t, 2) * start.y + 2 * (1 - t) * t * control.y + Math.pow(t, 2) * end.y;
                segmentPoints.push({ x, y });
                
                if (i > 0) {
                    const prevPoint = segmentPoints[i - 1];
                    const dx = x - prevPoint.x;
                    const dy = y - prevPoint.y;
                    totalLength += Math.sqrt(dx * dx + dy * dy);
                }
            }
            
            // 根据采样间隔确定实际需要的采样点数
            const sampleCount = Math.max(2, Math.floor(totalLength / samplingInterval) + 1);
            
            // 按弧长均匀采样
            let accumulatedLength = 0;
            let targetLength = 0;
            let j = 1;
            
            points.push(start);
            
            for (let i = 1; i < sampleCount - 1; i++) {
                targetLength = (totalLength * i) / (sampleCount - 1);
                
                while (j < segmentPoints.length && accumulatedLength < targetLength) {
                    const prevPoint = segmentPoints[j - 1];
                    const currPoint = segmentPoints[j];
                    const dx = currPoint.x - prevPoint.x;
                    const dy = currPoint.y - prevPoint.y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);
                    
                    if (accumulatedLength + segmentLength >= targetLength) {
                        const ratio = (targetLength - accumulatedLength) / segmentLength;
                        const x = prevPoint.x + dx * ratio;
                        const y = prevPoint.y + dy * ratio;
                        points.push({ x, y });
                        break;
                    }
                    
                    accumulatedLength += segmentLength;
                    j++;
                }
            }
            
            points.push(end);
            
            return points;
        }


        // 新增：计算曲线在某一点的曲率
        function calculateCurvatureAtPoint(points, index) {
            if (index <= 0 || index >= points.length - 1) {
                return 0; // 端点曲率为0
            }
            
            const p0 = points[index - 1];
            const p1 = points[index];
            const p2 = points[index + 1];
            
            // 计算向量
            const v0x = p1.x - p0.x;
            const v0y = p1.y - p0.y;
            const v1x = p2.x - p1.x;
            const v1y = p2.y - p1.y;
            
            // 计算曲率
            const crossProduct = v0x * v1y - v0y * v1x;
            const denom = Math.pow(Math.sqrt(v0x * v0x + v0y * v0y) * Math.sqrt(v1x * v1x + v1y * v1y), 3);
            
            return denom > 0 ? crossProduct / denom : 0;
        }

        // // 新增：处理道路曲率变化
        // function handleRoadCurvatureChange(event) {
        //     let value = parseFloat(event.target.value);
        //     // 确保值在有效范围内
        //     value = Math.max(-1, Math.min(1, value));
        //     event.target.value = value;
        //     curvature = value;
        // }

        // // 新增：处理选中道路的曲率变化
        // function handleSelectedRoadCurvatureChange(event) {
        //     let value = parseFloat(event.target.value);
        //     // 确保值在有效范围内
        //     value = Math.max(-1, Math.min(1, value));
        //     event.target.value = value;
        // }

                // 切换主模式（生成器/修改器）
        function switchMainMode(mode) {
            mainMode = mode;
            
            // 更新UI
            if (mode === 'generator') {
                generatorModeButton.classList.add('option-active');
                generatorModeButton.classList.remove('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5');
                modifierModeButton.classList.remove('option-active');
                modifierModeButton.classList.add('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5');
                editModeContainer.classList.remove('hidden');
                parameterPanel.classList.add('hidden');
                
                // 如果之前有选中的道路，取消选中
                if (selectedRoadId !== null) {
                    deselectRoad();
                }
                
                // 根据当前子模式更新状态
                if (currentMode === 'road') {
                    statusIndicator.innerHTML = '<i class="fa fa-circle text-green-500 mr-1"></i>就绪 - 请点击设定道路起点';
                } else {
                    statusIndicator.innerHTML = '<i class="fa fa-circle text-yellow-500 mr-1"></i>物体生成功能即将上线';
                }
                
                // 显示端点提示容器
                endpointHintsContainer.style.pointerEvents = 'auto';
            } else {
                modifierModeButton.classList.add('option-active');
                modifierModeButton.classList.remove('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5');
                generatorModeButton.classList.remove('option-active');
                generatorModeButton.classList.add('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5');
                editModeContainer.classList.add('hidden');
                parameterPanel.classList.remove('hidden');
                roadInfoPanel.classList.add('hidden');
                objectInfoPanel.classList.add('hidden');
                
                // 重置道路绘制状态
                resetRoadDrawing();
                
                // 隐藏端点提示容器
                endpointHintsContainer.style.pointerEvents = 'none';
                
                statusIndicator.innerHTML = '<i class="fa fa-circle text-blue-500 mr-1"></i>修改器模式 - 点击道路进行编辑';
            }
        }
        
        // 切换编辑模式
        function switchMode(mode) {
            if (mainMode !== 'generator') return; // 只有在生成器模式下才能切换
            
            currentMode = mode;
            // 更新UI
            if (mode === 'road') {
                roadModeButton.classList.add('option-active', 'bg-primary', 'text-white');
                roadModeButton.classList.remove('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5', 'bg-white', 'text-gray-700');
                objectModeButton.classList.remove('option-active', 'bg-primary', 'text-white');
                objectModeButton.classList.add('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5', 'bg-white', 'text-gray-700');
                intersectionModeButton.classList.remove('option-active', 'bg-primary', 'text-white');
                intersectionModeButton.classList.add('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5', 'bg-white', 'text-gray-700');
                roadInfoPanel.classList.remove('hidden');
                objectInfoPanel.classList.add('hidden');
                intersectionTypeContainer.classList.add('hidden');
                statusIndicator.innerHTML = '<i class="fa fa-circle text-green-500 mr-1"></i>就绪 - 请点击设定道路起点';
            } else if (mode === 'object') {
                objectModeButton.classList.add('option-active', 'bg-primary', 'text-white');
                objectModeButton.classList.remove('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5', 'bg-white', 'text-gray-700');
                roadModeButton.classList.remove('option-active', 'bg-primary', 'text-white');
                roadModeButton.classList.add('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5', 'bg-white', 'text-gray-700');
                intersectionModeButton.classList.remove('option-active', 'bg-primary', 'text-white');
                intersectionModeButton.classList.add('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5', 'bg-white', 'text-gray-700');
                objectInfoPanel.classList.remove('hidden');
                roadInfoPanel.classList.add('hidden');
                intersectionTypeContainer.classList.add('hidden');
                statusIndicator.innerHTML = '<i class="fa fa-circle text-yellow-500 mr-1"></i>请选择物体类型，然后在地图上点击放置';
            } else if (mode === 'intersection') {
                intersectionModeButton.classList.add('option-active', 'bg-primary', 'text-white');
                intersectionModeButton.classList.remove('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5', 'bg-white', 'text-gray-700');
                roadModeButton.classList.remove('option-active', 'bg-primary', 'text-white');
                roadModeButton.classList.add('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5', 'bg-white', 'text-gray-700');
                objectModeButton.classList.remove('option-active', 'bg-primary', 'text-white');
                objectModeButton.classList.add('border-gray-200', 'hover:border-primary/50', 'hover:bg-primary/5', 'bg-white', 'text-gray-700');
                objectInfoPanel.classList.add('hidden');
                roadInfoPanel.classList.add('hidden');
                intersectionTypeContainer.classList.remove('hidden');
                statusIndicator.innerHTML = '<i class="fa fa-circle text-purple-500 mr-1"></i>就绪 - 请点击画布放置路口';
            }
            
            // 重置道路绘制状态
            resetRoadDrawing();
        }

        // 检查是否点击了端点提示
        function checkEndpointClick(x, y) {
            const threshold = 10; // 点击阈值
            
            for (const road of roads) {
                // 检查起点
                const startDist = Math.sqrt(Math.pow(road.start.x - x, 2) + Math.pow(road.start.y - y, 2));
                if (startDist <= threshold) {
                    return road.start;
                }
                
                // 检查终点
                const endDist = Math.sqrt(Math.pow(road.end.x - x, 2) + Math.pow(road.end.y - y, 2));
                if (endDist <= threshold) {
                    return road.end;
                }
            }
            
            return null;
        }
        
        // 查找附近的道路
        function findNearbyRoads(point) {
            const threshold = 15; // 距离阈值
            const nearbyRoads = [];
            
            for (const road of roads) {
                // 检查与起点的距离
                const startDist = Math.sqrt(Math.pow(road.start.x - point.x, 2) + Math.pow(road.start.y - point.y, 2));
                if (startDist <= threshold) {
                    nearbyRoads.push({ id: road.id, point: 'start', distance: startDist });
                }
                
                // 检查与终点的距离
                const endDist = Math.sqrt(Math.pow(road.end.x - point.x, 2) + Math.pow(road.end.y - point.y, 2));
                if (endDist <= threshold) {
                    nearbyRoads.push({ id: road.id, point: 'end', distance: endDist });
                }
            }
            
            // 按距离排序
            nearbyRoads.sort((a, b) => a.distance - b.distance);
            
            return nearbyRoads;
        }
        
        // 处理修改器模式下的点击
        function handleModifierClick(event) {
            // 检查是否点击了道路
            const clickedElement = event.target.closest('.road-shape-group');
            if (clickedElement) {
                const roadId = parseInt(clickedElement.dataset.roadId);
                selectRoad(roadId);
                return;
            }
            
            // 检查是否点击了路口
            const clickedIntersection = event.target.closest('.intersection');
            if (clickedIntersection) {
                const intersectionId = parseInt(clickedIntersection.dataset.intersectionId);
                return;
            }
            
            // 如果点击了空白区域，取消所有选中
            deselectRoad();
            deselectIntersection();
        }
        
        // 处理鼠标移动事件（显示端点提示和位置信息）
        function handleMouseMove(event) {
            const rect = mapContainer.getBoundingClientRect();
            const x = Math.round(event.clientX - rect.left);
            const y = Math.round(event.clientY - rect.top);
            
            // 如果是生成器模式且当前是道路模式，更新端点提示
            if (mainMode === 'generator' || currentMode === 'road') {
                updateEndpointVisibility(x, y);
            }
            
            // 更新鼠标位置浮窗
            updateMousePositionTooltip(event.clientX, event.clientY, x, y,event);
        }
        
        // 更新鼠标位置浮窗
        function updateMousePositionTooltip(clientX, clientY, canvasX, canvasY) {
            const tooltip = document.getElementById('mouse-position-tooltip');
            const currentroad = event.target.closest('.road-shape-group');
            const now = new Date(); 
            // console.log(currentroad,now);
            if (mainMode === 'generator' && currentMode === 'road') {
                if (inzone) {
                    tooltip.textContent = `将创建新道路与${closestroadtype} ${closestroad}相连`;
                } else {
                    tooltip.textContent = `在: X: ${canvasX}, Y: ${canvasY},上放置 ${currentMode} ${isDrawingRoad ? '终点' : '起点'}`;
                }
            } else if (mainMode === 'generator' && currentMode === 'intersection') {
                tooltip.textContent = `在: X: ${canvasX}, Y: ${canvasY},上,绘制 ${currentMode}`;
            } else if(mainMode === 'generator' && currentMode == 'object'){
                if (currentroad) {
                    tooltip.textContent = `在道路 ${currentroad.dataset.roadId},上,绘制 ${objectName}`;
                }else{
                    tooltip.textContent = `在: X: ${canvasX}, Y: ${canvasY},上,绘制 ${objectName}`;
                }
            }
            
            // 更新浮窗位置（稍微偏移鼠标位置，避免遮挡）
            tooltip.style.left = `${clientX + 10}px`;
            tooltip.style.top = `${clientY - 30}px`;
        }
        
        // 处理鼠标进入画布事件
        function handleMouseEnter() {
            const tooltip = document.getElementById('mouse-position-tooltip');
            tooltip.classList.remove('hidden');
        }
        
        // 添加一个通用的函数用于提示用户输入文件名
        function promptForFileName(defaultName, fileType) {
            const userInput = prompt(`请输入${fileType}文件名（不包含扩展名）：`, defaultName);
            // 如果用户点击取消或关闭对话框，返回null
            if (userInput === null) {
                return null;
            }
            // 如果用户输入为空字符串，返回默认文件名（不带扩展名）
            return userInput.trim() || defaultName;
        }
        
        // 处理鼠标离开画布事件
        function handleMouseLeave() {
            const tooltip = document.getElementById('mouse-position-tooltip');
            tooltip.classList.add('hidden');
        }
        
        // 更新端点提示的可见性
        function updateEndpointVisibility(mouseX, mouseY) {
            const threshold = 8; // 鼠标距离阈值
            
            if (endpointHints.length === 0) {
                inzone = false;
                closestHint = null;
                validHints = []; // 清空有效提示数组
                return;
            }
            
            // 清空有效提示数组
            validHints = [];
            
            endpointHints.forEach(hint => {
                const hintX = parseFloat(hint.dataset.x);
                const hintY = parseFloat(hint.dataset.y);
                const distance = Math.sqrt(Math.pow(hintX - mouseX, 2) + Math.pow(hintY - mouseY, 2));
                
                // 先隐藏所有端点提示
                hint.style.opacity = '0';
                
                // 检查是否在阈值范围内
                if (distance <= threshold) {
                    validHints.push({hint, distance}); // 将满足条件的提示添加到数组
                    hint.style.opacity = '1'; // 显示所有满足条件的提示
                }
            });
            
            // 如果有满足条件的提示
            if (validHints.length > 0) {
                inzone = true;
                // 默认选择距离最近的提示作为后备
                validHints.sort((a, b) => a.distance - b.distance);
                closestHint = validHints[0].hint;
                closestroad = closestHint.dataset.road;
                closestroadtype = closestHint.dataset.type;
            } else {
                inzone = false;
                closestHint = null;
                closestroad = 0;
                closestroadtype = 0;
            }
        }


        // 更新端点提示
        function updateEndpointHints() {
            // 清空现有提示
            while (endpointHintsContainer.firstChild) {
                endpointHintsContainer.removeChild(endpointHintsContainer.firstChild);
            }
            endpointHints = [];
            
            // 为每条道路的端点创建提示
            roads.forEach(road => {
                // 创建起点提示
                const startHint = createEndpointHint(road.start.x, road.start.y,road.id,"road","start")
                endpointHintsContainer.appendChild(startHint);
                endpointHints.push(startHint);
                
                // 创建终点提示
                const endHint = createEndpointHint(road.end.x, road.end.y,road.id,"road","end")
                endpointHintsContainer.appendChild(endHint);
                endpointHints.push(endHint);
            });

            intersections.forEach(intersection=>{
                points = intersection.connectionPoints;
                points.forEach(point =>{
                    const intHint = createEndpointHint(point.x, point.y,intersection.id,"intersection","connection");
                    endpointHintsContainer.appendChild(intHint);
                    endpointHints.push(intHint);
                })
            })


        }
        
        // 创建端点提示元素
        function createEndpointHint(x,y,roadid,type,end) {
            const hint = document.createElement('div');
            hint.className = 'endpoint-hint';
            hint.style.left = `${x}px`;
            hint.style.top = `${y}px`;
            hint.style.opacity = '0';
            hint.dataset.x = x;
            hint.dataset.y = y;
            hint.dataset.road = roadid; 
            hint.dataset.type = type; 
            hint.dataset.end = end;
            // 点击提示时设置为道路起点
            hint.addEventListener('click', (event) => {
                event.stopPropagation();
                if (mainMode === 'generator' && currentMode === 'road' && !isDrawingRoad) {
                    startPoint = { x, y };
                    startPointElement.style.left = `${x}px`;
                    startPointElement.style.top = `${y}px`;
                    startPointElement.classList.remove('hidden');
                    statusIndicator.innerHTML = '<i class="fa fa-circle text-blue-500 mr-1"></i>已设置起点 - 请点击设定道路终点';
                }
            });
            
            return hint;
        }
        
        // 修改handleWheel函数以实现真正的画布缩放
        function handleWheel(event) {
            event.preventDefault();
            
            const rect = mapContainer.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // 计算当前鼠标位置相对于SVG的坐标（考虑当前缩放）
            const svgX = mouseX / zoomFactor;
            const svgY = mouseY / zoomFactor;
            
            // 调整缩放因子
            const delta = event.deltaY > 0 ? -0.1 : 0.1;
            zoomFactor = Math.max(0.1, Math.min(5, zoomFactor + delta));
            
            // 应用缩放变换，以鼠标位置为中心点
            mapSvg.setAttribute('transform', `translate(${mouseX - svgX * zoomFactor}, ${mouseY - svgY * zoomFactor}) scale(${zoomFactor})`);
            
            // 更新比例尺（可选，保持原功能）
            if (event.ctrlKey) {
                const scaleDelta = event.deltaY > 0 ? -10 : 10;
                scaleValue = Math.max(10, Math.min(200, scaleValue + scaleDelta));
                updateScaleBar();
            }
        }
        
        // 更新比例尺
        function updateScaleBar() {
            scaleLine.style.width = `${scaleValue}px`;
            scaleText.textContent = `${scaleValue}px`;
        }

        // 选中道路
        function selectRoad(roadId) {
            // 如果已经选中了道路，先取消选中
            deselectRoad();
            
            // 找到道路元素
            const roadElement = document.querySelector(`.road-element-group[data-road-id="${roadId}"]`);
            const roadShape = document.querySelector(`.road-shape-group[data-road-id="${roadId}"]`);
            if (roadElement) {
                // 添加选中样式
                roadElement.classList.add('road-selected');
                
                // 更新选中状态
                selectedRoadId = roadId;
                
                // 显示道路参数表单
                roadParameterForm.classList.remove('hidden');
                noSelectionText.classList.add('hidden');
                
                // 更新状态指示器
                statusIndicator.innerHTML = '<i class="fa fa-circle text-yellow-500 mr-1"></i>已选中道路 - 可编辑参数';
                
                // 加载道路参数到表单
                const road = roads.find(r => r.id === roadId);
                if (road) {
                    // 道路宽度由系统自动计算，这里设置为只读显示
                    selectedRoadWidthInput.value = road.width;
                    selectedRoadDirectionSelect.value = road.direction;
                    // 根据道路方向控制左侧车道数量输入框的显示
                    if (road.direction === 'two-way') {
                        leftLaneContainer.classList.remove('hidden');
                        selectedRoadLeftLanesInput.value = road.leftLanes || 1;
                    } else {
                        leftLaneContainer.classList.add('hidden');
                    }
                    
                    selectedRoadRightLanesInput.value = road.rightLanes || 1;
                    selectedRoadRightLaneCountChangeSelect.value = road.rightlaneCountChange || 'none';
                    selectedRoadLeftLaneCountChangeSelect.value = road.leftlaneCountChange || 'none';
                    selectedRoadAlignmentStart.value = road.startalignment || 'center-align';
                    selectedRoadAlignmentEnd.value = road.endalignment || 'center-align';
                    selectedRoadStartHeightInput.value = road.startHeight || 0;
                    selectedRoadEndHeightInput.value = road.endHeight || 0;

                    // 生成车道线设置表单
                    generateLaneMarkerControls(road);
                    // 生成车道参数控件
                    generateLaneParamsControls(road);
                    
                }
            }

            
            // 显示道路参数表单
            roadParameterForm.classList.remove('hidden');
            
            // 隐藏无选择提示
            noSelectionText.classList.add('hidden');
        }

        // 生成车道线设置控件
        function generateLaneMarkerControls(road) {
            // 清空现有控件
            const laneMarkersContainer = document.getElementById('lane-markers-container');
            laneMarkersContainer.innerHTML = '';
            // 如果道路没有车道线数据，先生成默认数据
            if (!road.lanemarkers || road.lanemarkers.length === 0) {
                const start = road.start;
                const end = road.end;
                const controlPt = road.controlPoint;
                const shoulderWidth = 5;
                const laneWidth = 3.75;
                
                // 清空现有车道线数据
                road.lanemarkers = [];
                
                // 双向道路：添加中央黄线
                if (road.direction === 'two-way') {
                    road.lanemarkers.push({
                        id: nextLaneMarkerId++,
                        name: '中央黄线',
                        color: '#FFFF00',
                        type: 'solid_double',
                        offset: 0
                    });
                }
                
                // 添加左侧车道线
                if (road.direction === 'two-way') {
                    for (let i = 1; i <= road.leftLanes; i++) {
                        road.lanemarkers.push({
                            id: nextLaneMarkerId++,
                            name: `左侧车道线${i}`,
                            color: '#FFFFFF',
                            type: 'solid_single',
                            offset: i * laneWidth
                        });
                    }
                }
                
                // 添加右侧车道线
                for (let i = 1; i <= road.rightLanes; i++) {
                    road.lanemarkers.push({
                        id: nextLaneMarkerId++,
                        name: `右侧车道线${i}`,
                        color: '#FFFFFF',
                        type: 'solid_single',
                        offset: -(i * laneWidth)
                    });
                }
            }

            // 为每条车道线创建控件
            road.lanemarkers.forEach((marker, index) => {
                const markerControl = document.createElement('div');
                markerControl.className = 'lane-marker-control p-3 border rounded-lg bg-gray-50';
                markerControl.dataset.markerIndex = index;
                markerControl.innerHTML = `

                    <div class="grid grid-cols-3 gap-2">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-sm font-medium text-gray-700">${marker.name}</span>
                        </div>
                        <div>
                            <label class="text-xs text-gray-500 mb-1 block">颜色</label>
                            <select class="lane-marker-color w-full text-sm border rounded px-2 py-1" data-index="${index}">
                                <option value="#FFFFFF" ${marker.color === '#FFFFFF' ? 'selected' : ''}>白色</option>
                                <option value="#FFFF00" ${marker.color === '#FFFF00' ? 'selected' : ''}>黄色</option>
                                <option value="#0000FF" ${marker.color === '#0000FF' ? 'selected' : ''}>蓝色</option>
                                <option value="#FF0000" ${marker.color === '#FF0000' ? 'selected' : ''}>红色</option>
                            </select>
                        </div>
                        <div>
                            <label class="text-xs text-gray-500 mb-1 block">类型</label>
                            <select class="lane-marker-type w-full text-sm border rounded px-2 py-1" data-index="${index}">
                                <option value="solid_single" ${marker.type === 'solid_single' ? 'selected' : ''}>单实线</option>
                                <option value="dashed_single" ${marker.type === 'dashed_single' ? 'selected' : ''}>单虚线</option>
                                <option value="solid_double" ${marker.type === 'solid_double' ? 'selected' : ''}>双实线</option>
                                <option value="dashed_double" ${marker.type === 'dashed_double' ? 'selected' : ''}>双虚线</option>
                                <option value="solid_dashed" ${marker.type === 'solid_dashed' ? 'selected' : ''}>左实右虚</option>
                                <option value="dashed_solid" ${marker.type === 'dashed_solid' ? 'selected' : ''}>左虚右实</option>
                            </select>
                        </div>
                    </div>
                `;
                
                laneMarkersContainer.appendChild(markerControl);
                
            });
        }

        // 取消选中道路
        function deselectRoad() {
            if (selectedRoadId !== null) {
                const roadElement = document.querySelector(`.road-element-group[data-road-id="${selectedRoadId}"]`);
                if (roadElement) {
                    roadElement.classList.remove('road-selected');
                }
                selectedRoadId = null;
                roadParameterForm.classList.add('hidden');
                if (selectedIntersectionId === null) {
                    noSelectionText.classList.remove('hidden');
                }
                statusIndicator.innerHTML = '<i class="fa fa-circle text-blue-500 mr-1"></i>修改器模式 - 点击道路或路口进行编辑';
            }
        }
        

        function calculateOffsetPoints(centerLinePoints, offset) {
            const offsetPoints = [];
            
            for (let i = 0; i < centerLinePoints.length; i++) {
                // 计算当前点与下一点的方向向量
                const current = centerLinePoints[i];
                let dx, dy;
                
                if (i === centerLinePoints.length - 1 && i > 0) {
                    const prev = centerLinePoints[i - 1];
                    dx = current.x - prev.x;
                    dy = current.y - prev.y;
                } else if (i < centerLinePoints.length - 1) {
                    const next = centerLinePoints[i + 1];
                    dx = next.x - current.x;
                    dy = next.y - current.y;
                } else {
                    dx = 1;
                    dy = 0;
                }
                
                const length = Math.max(0.001, Math.sqrt(dx * dx + dy * dy));
                
                // 计算垂直于道路方向的单位向量
                const perpX = -dy / length;
                const perpY = dx / length;
                
                // 基于偏移量计算新的点
                offsetPoints.push({
                    x: current.x + perpX * offset,
                    y: current.y + perpY * offset,
                    z: current.z,
                });
            }
            
            return offsetPoints;
        }
        
        // 绘制车道线函数
        function drawLaneMarker(roadGroup, offsetPoints, color, type) {

            // 根据车道线类型绘制不同样式
            if (type.includes('single') || type.includes('curb')) {
                // 单线路线
                const laneLinePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // 构建车道线的路径数据
                let laneLineData = `M ${offsetPoints[0].x},${offsetPoints[0].y} `;

                // 添加车道线的曲线点
                for (let i = 1; i < offsetPoints.length; i++) {
                    const p = offsetPoints[i];
                    laneLineData += `L ${p.x},${p.y} `;
                }

                laneLinePath.setAttribute('d', laneLineData);

                laneLinePath.setAttribute('stroke', color);
                
                if(type.includes('curb')){
                    width = "1";
                }else{width = "0.3";}
                laneLinePath.setAttribute('stroke-width', width);
                laneLinePath.setAttribute('fill', 'none');
                
                // 设置虚线样式
                if (type === 'dashed_single') {
                    laneLinePath.setAttribute('stroke-dasharray', '10, 5');
                }

                laneLinePath.classList.add('road-path');
                roadGroup.appendChild(laneLinePath);
            } else {
                // 双线路线
                const lineOffset = 0.3; // 双线之间的偏移量
                const lineWidth = 0.3; // 双线的宽度
                
                // 左侧线
                const leftLinePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const leftOffsetPoints = calculateOffsetPoints(offsetPoints,-lineOffset);
                
                let leftLineData = `M ${leftOffsetPoints[0].x},${leftOffsetPoints[0].y} `;
                for (let i = 1; i < leftOffsetPoints.length; i++) {
                    const p = leftOffsetPoints[i];
                    leftLineData += `L ${p.x},${p.y} `;
                }
                
                leftLinePath.setAttribute('d', leftLineData);
                leftLinePath.setAttribute('stroke', color);
                leftLinePath.setAttribute('stroke-width', lineWidth);
                leftLinePath.setAttribute('fill', 'none');
                
                // 右侧线
                const rightLinePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const rightOffsetPoints = calculateOffsetPoints(offsetPoints, +lineOffset);
                
                let rightLineData = `M ${rightOffsetPoints[0].x},${rightOffsetPoints[0].y} `;
                for (let i = 1; i < rightOffsetPoints.length; i++) {
                    const p = rightOffsetPoints[i];
                    rightLineData += `L ${p.x},${p.y} `;
                }
                
                rightLinePath.setAttribute('d', rightLineData);
                rightLinePath.setAttribute('stroke', color);
                rightLinePath.setAttribute('stroke-width', lineWidth);
                rightLinePath.setAttribute('fill', 'none');
                
                // 根据类型设置虚线样式
                if (type === 'dashed_double') {
                    leftLinePath.setAttribute('stroke-dasharray', '10, 5');
                    rightLinePath.setAttribute('stroke-dasharray', '10, 5');
                } else if (type === 'solid_dashed') {
                    // 左实右虚
                    rightLinePath.setAttribute('stroke-dasharray', '10, 5');
                } else if (type === 'dashed_solid') {
                    // 左虚右实
                    leftLinePath.setAttribute('stroke-dasharray', '10, 5');
                }
                
                leftLinePath.classList.add('road-path');
                rightLinePath.classList.add('road-path');
                roadGroup.appendChild(leftLinePath);
                roadGroup.appendChild(rightLinePath);
            }
            
            return offsetPoints; // 返回计算出的点集，供数据生成使用
        }

        // 生成车道线数据函数
        function generateLaneMarkerData(centerLinePoints,road,roadgeoform,color,type,offset,reduceoffset,index,gap,gapend,name,elimination,startingdirection,cuttype,heightvector) {
            const start= roadgeoform.startPoint;
            const end = roadgeoform.endPoint;
            // 计算采样点
            //const samplingPointsFull = calculateOffsetPoints(centerLinePoints, offset); //计算没有车道变更时的曲线
            const samplingPointsFull = calculateLaneReductionOffsetPoints(centerLinePoints,offset,reduceoffset,startingdirection);
            // 遍历所有的点，修改点的offset
            // 根据车道变更调整曲线
            const heightchangestart = parseInt(samplingPointsFull.length * 0.15);
            const heightchangeend = samplingPointsFull.length - heightchangestart;
            
            let height_start = heightvector[0]===0?parseInt(samplingPointsFull.length*0.1):heightvector[0];
            let height_end = heightvector[1]===8001?(samplingPointsFull.length-parseInt(samplingPointsFull.length*0.1)):heightvector[1];

            let elim_start = elimination[0] ;
            let elim_end = elimination[1]===8001?samplingPointsFull.length:elimination[1];
            const slope = (road.endHeight - road.startHeight) / (height_end - height_start);
            samplingPointsFull.forEach(function(point,index){
                if(index >= height_start && index <= height_end){
                    point.z = road.startHeight + slope * (index - height_start);
                }else if(index < height_start){
                    point.z = road.startHeight;
                }else if(index > height_end){
                    point.z = road.endHeight;
                }

            })


            samplingPoints = samplingPointsFull.slice(gap,samplingPointsFull.length-gapend)


            if (cuttype != "nocut"){
                samplingPoints = samplingPoints.slice(elim_start,elim_end);
            }
            
            

            
            // 计算曲率
            const curvatures = [];
            for (let i = 0; i < samplingPoints.length; i++) {
                curvatures.push(calculateCurvatureAtPoint(samplingPoints, i));
            }
            
            // 计算弧长
            const arcLengths = [];
            let accumulatedLength = 0;
            arcLengths.push(0);
            
            for (let i = 0; i < samplingPoints.length; i++) {
                if (i > 0) {
                    const prevPoint = samplingPoints[i - 1];
                    const currPoint = samplingPoints[i];
                    const dx = currPoint.x - prevPoint.x;
                    const dy = currPoint.y - prevPoint.y;
                    accumulatedLength += Math.sqrt(dx * dx + dy * dy);
                    arcLengths.push(accumulatedLength);
                }
            }
            // 创建车道线数据对象
            const laneMarkerData = {
                id: nextLaneMarkerId++,
                color: color,
                type: type,
                samplingPoints: samplingPoints,
                curvatures: curvatures,
                arcLengths: arcLengths,
                width: 1,
                index: index,
                offset:offset,
                points:samplingPoints,
                name:name
            };

            return laneMarkerData;
            
        }


        // 重置道路绘制状态
        function resetRoadDrawing() {
            startPoint = null;
            startPointElement.classList.add('hidden');
            endPointElement.classList.add('hidden');
            
            if (mainMode === 'generator' && currentMode === 'road') {
                statusIndicator.innerHTML = '<i class="fa fa-circle text-green-500 mr-1"></i>就绪 - 请点击设定道路起点';
            }
        }
        
        
        // 处理道路行驶方向变化
        function handleRoadDirectionChange(event) {
            roadDirection = event.target.value;
        }
        
        // 处理选中道路的宽度变化
        function handleSelectedRoadWidthChange(event) {
            let value = parseInt(event.target.value);
            // 确保值在有效范围内
            value = Math.max(1, Math.min(20, value));
            event.target.value = value;
        }
        
        // 更新道路信息
        function updateRoadInfo() {
            roadCountElement.textContent = roads.length;
            
            // 计算总长度
            let totalLength = 0;
            roads.forEach(road => {
                const dx = road.end.x - road.start.x;
                const dy = road.end.y - road.start.y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            });
            
            totalRoadLengthElement.textContent = `${Math.round(totalLength)} 像素`;
        }
        
        // 清空地图
        function clearMap() {
            // 移除所有道路

            roadSvg.innerHTML = '';
            roadnumberSvg.innerHTML = '';
            intersectSvg.innerHTML = '';
        
            // 清空道路数据
            roads = [];
            connections = [];
            intersections = [];
            
            // 重置道路绘制状态
            resetRoadDrawing();
            
            // 取消选中
            deselectRoad();
            
            // 更新道路信息
            updateRoadInfo();
            
            // 更新端点提示
            updateEndpointHints();
            
            // 显示提示
            showNotification('地图已清空', 'success');
        }
        
        function generatemapfile(customFileName){

            const mapData = {
                DataName:customFileName,
                DataType:"MapData",
                Physical_env:{
                    Road:roads.map((road) => {
                        return {
                            roadID:road.id,
                            totallanenumber:road.totalLanes,
                            startx:road.start.x,
                            starty:road.start.y,
                            endx:road.end.x,
                            endy:road.end.y,
                            roadDirection:roadDirection,
                            direction:road.direction,
                            roadborder:road.roadedge.map((edge)=>{
                                return {
                                    id:edge.id,
                                    type:edge.type,
                                    xpoints:edge.points.map((point) => {
                                        return point.x;
                                    }),
                                    ypoints:edge.points.map((point) => {
                                        return point.y;
                                    }),
                                    zpoints:edge.points.map((point) => {
                                        return point.z;
                                    }),
                                }
                            }),
                            centerline:{
                                xpoints:road.roadcenterline.map((point) => {
                                    return point.x;
                                }),
                                ypoints:road.roadcenterline.map((point) => {
                                    return point.y;
                                }),
                                zpoints:road.roadcenterline.map((point) => {
                                    return point.z;
                                }),
                            },
                            roadshape:{
                                xpoints:road.roadshape.map((point) => {
                                    return point.x;
                                }),
                                ypoints:road.roadshape.map((point) => {
                                    return point.y;
                                }),
                                zpoints:road.roadshape.map((point) => {
                                    return point.z;
                                }),
                            },
                            leftboundshape:{
                                xpoints:road.leftboundshape.map((point) => {
                                    return point.x;
                                }),
                                ypoints:road.leftboundshape.map((point) => {
                                    return point.y;
                                }),
                                zpoints:road.leftboundshape.map((point) => {
                                    return point.z;
                                }),
                            },
                            rightboundshape:{
                                xpoints:road.rightboundshape.map((point) => {
                                    return point.x;
                                }),
                                ypoints:road.rightboundshape.map((point) => {
                                    return point.y;
                                }),
                                zpoints:road.rightboundshape.map((point) => {
                                    return point.z;
                                }),
                            },
                            lanes:road.lanes.map((lane) => {
                                return {
                                    id:lane.id,
                                    left_line:lane.left_laneline_id,
                                    right_line:lane.right_laneline_id,
                                    width:lane.width,
                                    drivingdirection:lane.direction,
                                    turndirection:lane.turnDirection,
                                    xpoints:lane.lanecenter.points.map((point) => {
                                        return point.x;
                                    }),
                                    ypoints:lane.lanecenter.points.map((point) => {
                                        return point.y;
                                    }),
                                    zpoints:lane.lanecenter.points.map((point) => {
                                        return point.z;
                                    }),
                                }
                            }),
                            markers:road.lanemarkers.map((marker) => {
                                return {
                                    id:marker.id,
                                    type:marker.type,
                                    color:marker.color,
                                    xpoints:marker.points.map((point) => {
                                        return point.x;
                                    }),
                                    ypoints:marker.points.map((point) => {
                                        return point.y;
                                    }),
                                    zpoints:marker.points.map((point) => {
                                        return point.z;
                                    }),
                                }
                            }),
                            stopline:road.stopLines.map((stopline)=>{
                                return {
                                    id: stopline.id,
                                }
                            })
                        }
                    }),
            // 使用flatMap替代map，实现数组扁平化
                    Stopline:roads.flatMap((road) => {
                        // 确保road.stopLines存在且为数组
                        if (!road.stopLines || !Array.isArray(road.stopLines)) {
                            return [];
                        }
                        
                        return road.stopLines.map((stopline) => {
                            return {
                                ID: stopline.id,
                                startx:stopline.points[0].x,
                                starty:stopline.points[0].y,
                                endx:stopline.points[1].x,
                                endy:stopline.points[1].y,
                            };
                        });
                    }),
                    LandMarks:roads.flatMap((road) => {
                        // 确保road.stopLines存在且为数组
                        if (!road.arrows || !Array.isArray(road.arrows)) {
                            return [];
                        }
                        
                        return road.arrows.map((arrow) => {
                            return {
                                ID: arrow.id,
                                posx:arrow.posx,
                                posy:arrow.posy,
                                posz:arrow.posz,
                                angle:arrow.angle,
                                type:arrow.type,
                                RoadID:arrow.RoadID,
                                LaneID:arrow.LaneID
                            };
                        });
                    }),
                    TrafficLights:roads.flatMap((road) => {
                        // 确保road.stopLines存在且为数组
                        if (!road.trafficlights || !Array.isArray(road.trafficlights)) {
                            return [];
                        }
                        
                        return road.trafficlights.map((trafficlight) => {
                            return {
                                ID: trafficlight.id,
                                posx:trafficlight.position.x,
                                posy:trafficlight.position.y,
                                direction:trafficlight.direction,
                                rotation:trafficlight.rotation,
                            };
                        });
                    }),
                    StreetLights:roads.flatMap((road) => {
                        // 确保road.stopLines存在且为数组
                        if (!road.streetLights || !Array.isArray(road.streetLights)) {
                            return [];
                        }
                        
                        return road.streetLights.map((streetlight) => {
                            return {
                                ID: streetlight.id,
                                posx:streetlight.position.x,
                                posy:streetlight.position.y,
                                posz:streetlight.position.z,
                                // direction:streetlight.direction,
                                rotation:streetlight.rotation,
                            };
                        });
                    }),
                    ZebraCrossings:roads.flatMap((road) => {
                        // 确保road.stopLines存在且为数组
                        if (!road.zebraCrossings || !Array.isArray(road.zebraCrossings)) {
                            return [];
                        }
                        
                        return road.zebraCrossings.map((zebracrossing) => {
                            return {
                                ID: zebracrossing.id,
                                geo:zebracrossing.points,
                            };
                        });
                    }),

            
                Intersection:intersections.map((intersection) =>{
                    return {
                        interID:intersection.id,
                        posx:intersection.x,
                        posy:intersection.y,
                        type:intersection.type,
                        size:intersection.size,
                    }
                })
            }}
            // 创建JSON文件
            const dataStr = JSON.stringify(mapData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            // 创建下载链接
            const link = document.createElement('a');
            link.href = url;
            // 使用自定义文件名或默认文件名
            link.download = customFileName || 'MapDataJW.json';
            
            // 触发下载
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // 释放URL对象
            URL.revokeObjectURL(url);
            
            // 显示提示
            showNotification('地图数据已导出', 'success');
        }


        // 修改saveCanvas函数以生成不包含roadnumberSvg的高分辨率图片
        function saveCanvas(customFileName) {
            // 隐藏不需要导出的元素
            const elementsToHide = [startPointElement, endPointElement, scaleBar, endpointHintsContainer, roadnumberSvg];
            const originalDisplayStyles = [];
            
            // 临时隐藏元素
            elementsToHide.forEach((el, index) => {
                if (el) {
                    // 保存原始显示样式
                    originalDisplayStyles[index] = el.style.display;
                    // 强制隐藏元素
                    el.style.display = 'none';
                } else {
                    originalDisplayStyles[index] = null;
                }
            });
            
            // 使用setTimeout确保样式更改生效
            setTimeout(() => {
                // 创建一个临时canvas来渲染SVG
                const svgData = new XMLSerializer().serializeToString(mapSvg);
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                // 设置canvas尺寸为原始尺寸的2倍（高分辨率）
                const rect = mapContainer.getBoundingClientRect();
                const scaleFactor = 10; // 可以调整这个值以获得更高的分辨率
                canvas.width = rect.width * scaleFactor;
                canvas.height = rect.height * scaleFactor;
                
                // 设置canvas背景为白色
                ctx.fillStyle = 'gray';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 创建一个临时的SVG URL
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const svgUrl = URL.createObjectURL(svgBlob);
                
                // 当图片加载完成后绘制到canvas
                img.onload = function() {
                    // 以更高分辨率绘制SVG内容
                    ctx.scale(scaleFactor, scaleFactor);
                    ctx.drawImage(img, 0, 0, rect.width, rect.height);
                    
                    // 将canvas转换为图片URL并下载
                    const imageUrl = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.href = imageUrl;
                    
                    // 使用自定义文件名或默认文件名
                    if (customFileName) {
                        link.download = `${customFileName}.png`;
                    } else {
                        link.download = `RoadMap_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
                    }
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // 释放URL对象
                    URL.revokeObjectURL(svgUrl);
                    
                    // 恢复隐藏的元素
                    elementsToHide.forEach((el, index) => {
                        if (el) {
                            // 恢复原始显示样式
                            el.style.display = originalDisplayStyles[index];
                        }
                    });
                    
                    // 显示提示
                    showNotification('画布已保存为高分辨率图片', 'success');
                };
                
                // 设置图片源为SVG URL
                img.src = svgUrl;
            }, 100); // 短暂延迟确保样式更改生效
        }
                
        
        function movetheelement(){
            if (!selectedRoadId) {
                showNotification('请先选择一条道路', 'error');
                return;
            }
            const roadElement = document.querySelector(`.road-element-group[data-road-id="${selectedRoadId}"]`);
            const roadShape = document.querySelector(`.road-shape-group[data-road-id="${selectedRoadId}"]`);

            roadSvg.appendChild(roadShape)
            roadSvg.appendChild(roadElement)
        }

        // 显示通知
        function showNotification(message, type = 'info') {
            // 创建通知元素
            const notification = document.createElement('div');
            notification.className = `fixed bottom-4 right-4 px-4 py-2 rounded-lg shadow-lg z-50 transition-all duration-300 transform translate-y-10 opacity-0`;
            
            // 设置样式和图标
            if (type === 'success') {
                notification.classList.add('bg-green-100', 'text-green-800', 'border', 'border-green-200');
                notification.innerHTML = `<i class="fa fa-check-circle mr-2"></i>${message}`;
            } else if (type === 'error') {
                notification.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-200');
                notification.innerHTML = `<i class="fa fa-exclamation-circle mr-2"></i>${message}`;
            } else {
                notification.classList.add('bg-blue-100', 'text-blue-800', 'border', 'border-blue-200');
                notification.innerHTML = `<i class="fa fa-info-circle mr-2"></i>${message}`;
            }
            
            // 添加到页面
            document.body.appendChild(notification);
            
            // 显示动画
            setTimeout(() => {
                notification.classList.remove('translate-y-10', 'opacity-0');
            }, 10);
            
            // 3秒后隐藏
            setTimeout(() => {
                notification.classList.add('translate-y-10', 'opacity-0');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }
        
        // 在页面加载时初始化表单
        window.addEventListener('load', function() {
            updateRoadParameterForm();
            document.getElementById('apply-changes').addEventListener('click', applyRoadChanges);
            document.getElementById('move-to-top').addEventListener('click', movetheelement);
            const style = document.createElement('style');
            style.textContent = `
                .intersection-selected rect {
                    stroke: #00FF00 !important;
                    stroke-width: 3px !important;
                }
                .intersection {
                    cursor: grab;
                }
                .intersection:hover rect {
                    stroke: #FF0000;
                }
            `;
            document.head.appendChild(style);
        });
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', init);
    </script>
    <!-- 添加鼠标位置提示框 -->
    <div id="mouse-position-tooltip" class="fixed bg-gray-800 text-white text-xs px-2 py-1 rounded shadow-lg pointer-events-none hidden">
        位置: X: 0, Y: 0
    </div>
</body>

</html>

